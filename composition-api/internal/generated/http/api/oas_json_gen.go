// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Card) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Card) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("patient_id")
		json.EncodeUUID(e, s.PatientID)
	}
	{
		e.FieldStart("doctor_id")
		json.EncodeUUID(e, s.DoctorID)
	}
	{
		if s.Diagnosis.Set {
			e.FieldStart("diagnosis")
			s.Diagnosis.Encode(e)
		}
	}
}

var jsonFieldsNameOfCard = [3]string{
	0: "patient_id",
	1: "doctor_id",
	2: "diagnosis",
}

// Decode decodes Card from json.
func (s *Card) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Card to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "patient_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PatientID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_id\"")
			}
		case "doctor_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DoctorID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"doctor_id\"")
			}
		case "diagnosis":
			if err := func() error {
				s.Diagnosis.Reset()
				if err := s.Diagnosis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnosis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Card")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCard) {
					name = jsonFieldsNameOfCard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Card) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Card) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Contor as json.
func (s Contor) Encode(e *jx.Encoder) {
	unwrapped := []ContorItem(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes Contor from json.
func (s *Contor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Contor to nil")
	}
	var unwrapped []ContorItem
	if err := func() error {
		unwrapped = make([]ContorItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContorItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Contor(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Contor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Contor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContorItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContorItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfContorItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes ContorItem from json.
func (s *ContorItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContorItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContorItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContorItem) {
					name = jsonFieldsNameOfContorItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContorItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContorItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyCopyCreateCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyCopyCreateCreated) encodeFields(e *jx.Encoder) {
	{
		if s.Pk.Set {
			e.FieldStart("pk")
			s.Pk.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyCopyCreateCreated = [2]string{
	0: "pk",
	1: "id",
}

// Decode decodes CytologyCopyCreateCreated from json.
func (s *CytologyCopyCreateCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyCopyCreateCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pk":
			if err := func() error {
				s.Pk.Reset()
				if err := s.Pk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyCopyCreateCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyCopyCreateCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyCopyCreateCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyCopyCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyCopyCreateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Pk.Set {
			e.FieldStart("pk")
			s.Pk.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
}

var jsonFieldsNameOfCytologyCopyCreateReq = [2]string{
	0: "pk",
	1: "id",
}

// Decode decodes CytologyCopyCreateReq from json.
func (s *CytologyCopyCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyCopyCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pk":
			if err := func() error {
				s.Pk.Reset()
				if err := s.Pk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pk\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyCopyCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyCopyCreateReq) {
					name = jsonFieldsNameOfCytologyCopyCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyCopyCreateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyCopyCreateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyCreateCreateCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyCreateCreateCreated) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.PatientCard.Set {
			e.FieldStart("patient_card")
			s.PatientCard.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyCreateCreateCreated = [14]string{
	0:  "id",
	1:  "image",
	2:  "is_last",
	3:  "diagnos_date",
	4:  "details",
	5:  "diagnostic_marking",
	6:  "diagnostic_number",
	7:  "material_type",
	8:  "calcitonin",
	9:  "calcitonin_in_flush",
	10: "thyroglobulin",
	11: "prev",
	12: "parent_prev",
	13: "patient_card",
}

// Decode decodes CytologyCreateCreateCreated from json.
func (s *CytologyCreateCreateCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyCreateCreateCreated to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CytologyCreateCreateCreatedDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "patient_card":
			if err := func() error {
				s.PatientCard.Reset()
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyCreateCreateCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyCreateCreateCreated) {
					name = jsonFieldsNameOfCytologyCreateCreateCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyCreateCreateCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyCreateCreateCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyCreateCreateCreatedDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyCreateCreateCreatedDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyCreateCreateCreatedDetails = [0]string{}

// Decode decodes CytologyCreateCreateCreatedDetails from json.
func (s *CytologyCreateCreateCreatedDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyCreateCreateCreatedDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyCreateCreateCreatedDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyCreateCreateCreatedDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyCreateCreateCreatedDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyCreateCreateCreatedDiagnosticMarking as json.
func (s CytologyCreateCreateCreatedDiagnosticMarking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyCreateCreateCreatedDiagnosticMarking from json.
func (s *CytologyCreateCreateCreatedDiagnosticMarking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyCreateCreateCreatedDiagnosticMarking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyCreateCreateCreatedDiagnosticMarking(v) {
	case CytologyCreateCreateCreatedDiagnosticMarking11:
		*s = CytologyCreateCreateCreatedDiagnosticMarking11
	case CytologyCreateCreateCreatedDiagnosticMarking23:
		*s = CytologyCreateCreateCreatedDiagnosticMarking23
	default:
		*s = CytologyCreateCreateCreatedDiagnosticMarking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyCreateCreateCreatedDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyCreateCreateCreatedDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyCreateCreateCreatedMaterialType as json.
func (s CytologyCreateCreateCreatedMaterialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyCreateCreateCreatedMaterialType from json.
func (s *CytologyCreateCreateCreatedMaterialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyCreateCreateCreatedMaterialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyCreateCreateCreatedMaterialType(v) {
	case CytologyCreateCreateCreatedMaterialTypeGS:
		*s = CytologyCreateCreateCreatedMaterialTypeGS
	case CytologyCreateCreateCreatedMaterialTypeBP:
		*s = CytologyCreateCreateCreatedMaterialTypeBP
	case CytologyCreateCreateCreatedMaterialTypeTP:
		*s = CytologyCreateCreateCreatedMaterialTypeTP
	case CytologyCreateCreateCreatedMaterialTypePTP:
		*s = CytologyCreateCreateCreatedMaterialTypePTP
	case CytologyCreateCreateCreatedMaterialTypeLNP:
		*s = CytologyCreateCreateCreatedMaterialTypeLNP
	default:
		*s = CytologyCreateCreateCreatedMaterialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyCreateCreateCreatedMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyCreateCreateCreatedMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyHistoryReadOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyHistoryReadOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCytologyHistoryReadOK = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes CytologyHistoryReadOK from json.
func (s *CytologyHistoryReadOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyHistoryReadOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]CytologyHistoryReadOKResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologyHistoryReadOKResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyHistoryReadOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyHistoryReadOK) {
					name = jsonFieldsNameOfCytologyHistoryReadOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyHistoryReadOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyHistoryReadOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyHistoryReadOKResultsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyHistoryReadOKResultsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.PatientCard.Set {
			e.FieldStart("patient_card")
			s.PatientCard.Encode(e)
		}
	}
	{
		if s.OriginalImage.Set {
			e.FieldStart("original_image")
			s.OriginalImage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyHistoryReadOKResultsItem = [14]string{
	0:  "id",
	1:  "is_last",
	2:  "diagnos_date",
	3:  "details",
	4:  "diagnostic_marking",
	5:  "diagnostic_number",
	6:  "material_type",
	7:  "calcitonin",
	8:  "calcitonin_in_flush",
	9:  "thyroglobulin",
	10: "prev",
	11: "parent_prev",
	12: "patient_card",
	13: "original_image",
}

// Decode decodes CytologyHistoryReadOKResultsItem from json.
func (s *CytologyHistoryReadOKResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyHistoryReadOKResultsItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CytologyHistoryReadOKResultsItemDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "patient_card":
			if err := func() error {
				s.PatientCard.Reset()
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		case "original_image":
			if err := func() error {
				s.OriginalImage.Reset()
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyHistoryReadOKResultsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyHistoryReadOKResultsItem) {
					name = jsonFieldsNameOfCytologyHistoryReadOKResultsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyHistoryReadOKResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyHistoryReadOKResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyHistoryReadOKResultsItemDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyHistoryReadOKResultsItemDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyHistoryReadOKResultsItemDetails = [0]string{}

// Decode decodes CytologyHistoryReadOKResultsItemDetails from json.
func (s *CytologyHistoryReadOKResultsItemDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyHistoryReadOKResultsItemDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyHistoryReadOKResultsItemDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyHistoryReadOKResultsItemDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyHistoryReadOKResultsItemDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyHistoryReadOKResultsItemDiagnosticMarking as json.
func (s CytologyHistoryReadOKResultsItemDiagnosticMarking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyHistoryReadOKResultsItemDiagnosticMarking from json.
func (s *CytologyHistoryReadOKResultsItemDiagnosticMarking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyHistoryReadOKResultsItemDiagnosticMarking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyHistoryReadOKResultsItemDiagnosticMarking(v) {
	case CytologyHistoryReadOKResultsItemDiagnosticMarking11:
		*s = CytologyHistoryReadOKResultsItemDiagnosticMarking11
	case CytologyHistoryReadOKResultsItemDiagnosticMarking23:
		*s = CytologyHistoryReadOKResultsItemDiagnosticMarking23
	default:
		*s = CytologyHistoryReadOKResultsItemDiagnosticMarking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyHistoryReadOKResultsItemDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyHistoryReadOKResultsItemDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyHistoryReadOKResultsItemMaterialType as json.
func (s CytologyHistoryReadOKResultsItemMaterialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyHistoryReadOKResultsItemMaterialType from json.
func (s *CytologyHistoryReadOKResultsItemMaterialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyHistoryReadOKResultsItemMaterialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyHistoryReadOKResultsItemMaterialType(v) {
	case CytologyHistoryReadOKResultsItemMaterialTypeGS:
		*s = CytologyHistoryReadOKResultsItemMaterialTypeGS
	case CytologyHistoryReadOKResultsItemMaterialTypeBP:
		*s = CytologyHistoryReadOKResultsItemMaterialTypeBP
	case CytologyHistoryReadOKResultsItemMaterialTypeTP:
		*s = CytologyHistoryReadOKResultsItemMaterialTypeTP
	case CytologyHistoryReadOKResultsItemMaterialTypePTP:
		*s = CytologyHistoryReadOKResultsItemMaterialTypePTP
	case CytologyHistoryReadOKResultsItemMaterialTypeLNP:
		*s = CytologyHistoryReadOKResultsItemMaterialTypeLNP
	default:
		*s = CytologyHistoryReadOKResultsItemMaterialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyHistoryReadOKResultsItemMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyHistoryReadOKResultsItemMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyReadOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyReadOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("original_image")
		s.OriginalImage.Encode(e)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
}

var jsonFieldsNameOfCytologyReadOK = [2]string{
	0: "original_image",
	1: "info",
}

// Decode decodes CytologyReadOK from json.
func (s *CytologyReadOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyReadOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "original_image":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyReadOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyReadOK) {
					name = jsonFieldsNameOfCytologyReadOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyReadOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyReadOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyReadOKInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyReadOKInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("patient")
		s.Patient.Encode(e)
	}
	{
		e.FieldStart("patient_card")
		s.PatientCard.Encode(e)
	}
	{
		e.FieldStart("image_group")
		s.ImageGroup.Encode(e)
	}
}

var jsonFieldsNameOfCytologyReadOKInfo = [3]string{
	0: "patient",
	1: "patient_card",
	2: "image_group",
}

// Decode decodes CytologyReadOKInfo from json.
func (s *CytologyReadOKInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyReadOKInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "patient":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Patient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient\"")
			}
		case "patient_card":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		case "image_group":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ImageGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyReadOKInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyReadOKInfo) {
					name = jsonFieldsNameOfCytologyReadOKInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyReadOKInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyReadOKInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyReadOKInfoImageGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyReadOKInfoImageGroup) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.OriginalImage.Set {
			e.FieldStart("original_image")
			s.OriginalImage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyReadOKInfoImageGroup = [13]string{
	0:  "id",
	1:  "is_last",
	2:  "diagnos_date",
	3:  "details",
	4:  "diagnostic_marking",
	5:  "diagnostic_number",
	6:  "material_type",
	7:  "calcitonin",
	8:  "calcitonin_in_flush",
	9:  "thyroglobulin",
	10: "prev",
	11: "parent_prev",
	12: "original_image",
}

// Decode decodes CytologyReadOKInfoImageGroup from json.
func (s *CytologyReadOKInfoImageGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyReadOKInfoImageGroup to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CytologyReadOKInfoImageGroupDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "original_image":
			if err := func() error {
				s.OriginalImage.Reset()
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyReadOKInfoImageGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyReadOKInfoImageGroup) {
					name = jsonFieldsNameOfCytologyReadOKInfoImageGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyReadOKInfoImageGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyReadOKInfoImageGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyReadOKInfoImageGroupDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyReadOKInfoImageGroupDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyReadOKInfoImageGroupDetails = [0]string{}

// Decode decodes CytologyReadOKInfoImageGroupDetails from json.
func (s *CytologyReadOKInfoImageGroupDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyReadOKInfoImageGroupDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyReadOKInfoImageGroupDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyReadOKInfoImageGroupDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyReadOKInfoImageGroupDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyReadOKInfoImageGroupDiagnosticMarking as json.
func (s CytologyReadOKInfoImageGroupDiagnosticMarking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyReadOKInfoImageGroupDiagnosticMarking from json.
func (s *CytologyReadOKInfoImageGroupDiagnosticMarking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyReadOKInfoImageGroupDiagnosticMarking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyReadOKInfoImageGroupDiagnosticMarking(v) {
	case CytologyReadOKInfoImageGroupDiagnosticMarking11:
		*s = CytologyReadOKInfoImageGroupDiagnosticMarking11
	case CytologyReadOKInfoImageGroupDiagnosticMarking23:
		*s = CytologyReadOKInfoImageGroupDiagnosticMarking23
	default:
		*s = CytologyReadOKInfoImageGroupDiagnosticMarking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyReadOKInfoImageGroupDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyReadOKInfoImageGroupDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyReadOKInfoImageGroupMaterialType as json.
func (s CytologyReadOKInfoImageGroupMaterialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyReadOKInfoImageGroupMaterialType from json.
func (s *CytologyReadOKInfoImageGroupMaterialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyReadOKInfoImageGroupMaterialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyReadOKInfoImageGroupMaterialType(v) {
	case CytologyReadOKInfoImageGroupMaterialTypeGS:
		*s = CytologyReadOKInfoImageGroupMaterialTypeGS
	case CytologyReadOKInfoImageGroupMaterialTypeBP:
		*s = CytologyReadOKInfoImageGroupMaterialTypeBP
	case CytologyReadOKInfoImageGroupMaterialTypeTP:
		*s = CytologyReadOKInfoImageGroupMaterialTypeTP
	case CytologyReadOKInfoImageGroupMaterialTypePTP:
		*s = CytologyReadOKInfoImageGroupMaterialTypePTP
	case CytologyReadOKInfoImageGroupMaterialTypeLNP:
		*s = CytologyReadOKInfoImageGroupMaterialTypeLNP
	default:
		*s = CytologyReadOKInfoImageGroupMaterialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyReadOKInfoImageGroupMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyReadOKInfoImageGroupMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyReadOKOriginalImage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyReadOKOriginalImage) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreateDate.Set {
			e.FieldStart("create_date")
			s.CreateDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DelayTime.Set {
			e.FieldStart("delay_time")
			s.DelayTime.Encode(e)
		}
	}
	{
		if s.ViewedFlag.Set {
			e.FieldStart("viewed_flag")
			s.ViewedFlag.Encode(e)
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.FilePath.Set {
			e.FieldStart("file_path")
			s.FilePath.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyReadOKOriginalImage = [6]string{
	0: "id",
	1: "create_date",
	2: "delay_time",
	3: "viewed_flag",
	4: "image",
	5: "file_path",
}

// Decode decodes CytologyReadOKOriginalImage from json.
func (s *CytologyReadOKOriginalImage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyReadOKOriginalImage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_date":
			if err := func() error {
				s.CreateDate.Reset()
				if err := s.CreateDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_date\"")
			}
		case "delay_time":
			if err := func() error {
				s.DelayTime.Reset()
				if err := s.DelayTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delay_time\"")
			}
		case "viewed_flag":
			if err := func() error {
				s.ViewedFlag.Reset()
				if err := s.ViewedFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewed_flag\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "file_path":
			if err := func() error {
				s.FilePath.Reset()
				if err := s.FilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyReadOKOriginalImage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyReadOKOriginalImage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyReadOKOriginalImage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentGroupCreateCreateCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentGroupCreateCreateCreated) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.SegType.Set {
			e.FieldStart("seg_type")
			s.SegType.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentGroupCreateCreateCreated = [3]string{
	0: "id",
	1: "data",
	2: "seg_type",
}

// Decode decodes CytologySegmentGroupCreateCreateCreated from json.
func (s *CytologySegmentGroupCreateCreateCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentGroupCreateCreateCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "seg_type":
			if err := func() error {
				s.SegType.Reset()
				if err := s.SegType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seg_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentGroupCreateCreateCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentGroupCreateCreateCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentGroupCreateCreateCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentGroupCreateCreateCreatedData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentGroupCreateCreateCreatedData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCytologySegmentGroupCreateCreateCreatedData = [1]string{
	0: "points",
}

// Decode decodes CytologySegmentGroupCreateCreateCreatedData from json.
func (s *CytologySegmentGroupCreateCreateCreatedData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentGroupCreateCreateCreatedData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "points":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Points = make([]CytologySegmentGroupCreateCreateCreatedDataPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentGroupCreateCreateCreatedDataPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentGroupCreateCreateCreatedData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentGroupCreateCreateCreatedData) {
					name = jsonFieldsNameOfCytologySegmentGroupCreateCreateCreatedData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentGroupCreateCreateCreatedData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentGroupCreateCreateCreatedData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentGroupCreateCreateCreatedDataPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentGroupCreateCreateCreatedDataPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentGroupCreateCreateCreatedDataPointsItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes CytologySegmentGroupCreateCreateCreatedDataPointsItem from json.
func (s *CytologySegmentGroupCreateCreateCreatedDataPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentGroupCreateCreateCreatedDataPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentGroupCreateCreateCreatedDataPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentGroupCreateCreateCreatedDataPointsItem) {
					name = jsonFieldsNameOfCytologySegmentGroupCreateCreateCreatedDataPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentGroupCreateCreateCreatedDataPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentGroupCreateCreateCreatedDataPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentGroupCreateCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentGroupCreateCreateReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		e.FieldStart("seg_type")
		s.SegType.Encode(e)
	}
}

var jsonFieldsNameOfCytologySegmentGroupCreateCreateReq = [2]string{
	0: "data",
	1: "seg_type",
}

// Decode decodes CytologySegmentGroupCreateCreateReq from json.
func (s *CytologySegmentGroupCreateCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentGroupCreateCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "seg_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SegType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seg_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentGroupCreateCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentGroupCreateCreateReq) {
					name = jsonFieldsNameOfCytologySegmentGroupCreateCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentGroupCreateCreateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentGroupCreateCreateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentGroupCreateCreateReqData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentGroupCreateCreateReqData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCytologySegmentGroupCreateCreateReqData = [1]string{
	0: "points",
}

// Decode decodes CytologySegmentGroupCreateCreateReqData from json.
func (s *CytologySegmentGroupCreateCreateReqData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentGroupCreateCreateReqData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "points":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Points = make([]CytologySegmentGroupCreateCreateReqDataPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentGroupCreateCreateReqDataPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentGroupCreateCreateReqData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentGroupCreateCreateReqData) {
					name = jsonFieldsNameOfCytologySegmentGroupCreateCreateReqData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentGroupCreateCreateReqData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentGroupCreateCreateReqData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentGroupCreateCreateReqDataPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentGroupCreateCreateReqDataPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentGroupCreateCreateReqDataPointsItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes CytologySegmentGroupCreateCreateReqDataPointsItem from json.
func (s *CytologySegmentGroupCreateCreateReqDataPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentGroupCreateCreateReqDataPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentGroupCreateCreateReqDataPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentGroupCreateCreateReqDataPointsItem) {
					name = jsonFieldsNameOfCytologySegmentGroupCreateCreateReqDataPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentGroupCreateCreateReqDataPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentGroupCreateCreateReqDataPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologySegmentGroupCreateCreateReqSegType as json.
func (s CytologySegmentGroupCreateCreateReqSegType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologySegmentGroupCreateCreateReqSegType from json.
func (s *CytologySegmentGroupCreateCreateReqSegType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentGroupCreateCreateReqSegType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologySegmentGroupCreateCreateReqSegType(v) {
	case CytologySegmentGroupCreateCreateReqSegTypeNIL:
		*s = CytologySegmentGroupCreateCreateReqSegTypeNIL
	case CytologySegmentGroupCreateCreateReqSegTypeNIR:
		*s = CytologySegmentGroupCreateCreateReqSegTypeNIR
	case CytologySegmentGroupCreateCreateReqSegTypeNIM:
		*s = CytologySegmentGroupCreateCreateReqSegTypeNIM
	case CytologySegmentGroupCreateCreateReqSegTypeCNO:
		*s = CytologySegmentGroupCreateCreateReqSegTypeCNO
	case CytologySegmentGroupCreateCreateReqSegTypeCGE:
		*s = CytologySegmentGroupCreateCreateReqSegTypeCGE
	case CytologySegmentGroupCreateCreateReqSegTypeC2N:
		*s = CytologySegmentGroupCreateCreateReqSegTypeC2N
	case CytologySegmentGroupCreateCreateReqSegTypeCPS:
		*s = CytologySegmentGroupCreateCreateReqSegTypeCPS
	case CytologySegmentGroupCreateCreateReqSegTypeCFC:
		*s = CytologySegmentGroupCreateCreateReqSegTypeCFC
	case CytologySegmentGroupCreateCreateReqSegTypeCLY:
		*s = CytologySegmentGroupCreateCreateReqSegTypeCLY
	case CytologySegmentGroupCreateCreateReqSegTypeSOS:
		*s = CytologySegmentGroupCreateCreateReqSegTypeSOS
	case CytologySegmentGroupCreateCreateReqSegTypeSDS:
		*s = CytologySegmentGroupCreateCreateReqSegTypeSDS
	case CytologySegmentGroupCreateCreateReqSegTypeSMS:
		*s = CytologySegmentGroupCreateCreateReqSegTypeSMS
	case CytologySegmentGroupCreateCreateReqSegTypeSTS:
		*s = CytologySegmentGroupCreateCreateReqSegTypeSTS
	case CytologySegmentGroupCreateCreateReqSegTypeSPS:
		*s = CytologySegmentGroupCreateCreateReqSegTypeSPS
	case CytologySegmentGroupCreateCreateReqSegTypeSNM:
		*s = CytologySegmentGroupCreateCreateReqSegTypeSNM
	case CytologySegmentGroupCreateCreateReqSegTypeSTM:
		*s = CytologySegmentGroupCreateCreateReqSegTypeSTM
	default:
		*s = CytologySegmentGroupCreateCreateReqSegType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologySegmentGroupCreateCreateReqSegType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentGroupCreateCreateReqSegType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdatePartialUpdateOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SegmentGroup.Set {
			e.FieldStart("segment_group")
			s.SegmentGroup.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentUpdatePartialUpdateOK = [2]string{
	0: "points",
	1: "segment_group",
}

// Decode decodes CytologySegmentUpdatePartialUpdateOK from json.
func (s *CytologySegmentUpdatePartialUpdateOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdatePartialUpdateOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "points":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Points = make([]CytologySegmentUpdatePartialUpdateOKPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentUpdatePartialUpdateOKPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "segment_group":
			if err := func() error {
				s.SegmentGroup.Reset()
				if err := s.SegmentGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdatePartialUpdateOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdatePartialUpdateOK) {
					name = jsonFieldsNameOfCytologySegmentUpdatePartialUpdateOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdatePartialUpdateOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateOKPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdatePartialUpdateOKPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentUpdatePartialUpdateOKPointsItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes CytologySegmentUpdatePartialUpdateOKPointsItem from json.
func (s *CytologySegmentUpdatePartialUpdateOKPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdatePartialUpdateOKPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdatePartialUpdateOKPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdatePartialUpdateOKPointsItem) {
					name = jsonFieldsNameOfCytologySegmentUpdatePartialUpdateOKPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateOKPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdatePartialUpdateOKPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdatePartialUpdateReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SegmentGroup.Set {
			e.FieldStart("segment_group")
			s.SegmentGroup.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentUpdatePartialUpdateReq = [2]string{
	0: "points",
	1: "segment_group",
}

// Decode decodes CytologySegmentUpdatePartialUpdateReq from json.
func (s *CytologySegmentUpdatePartialUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdatePartialUpdateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "points":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Points = make([]CytologySegmentUpdatePartialUpdateReqPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentUpdatePartialUpdateReqPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "segment_group":
			if err := func() error {
				s.SegmentGroup.Reset()
				if err := s.SegmentGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdatePartialUpdateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdatePartialUpdateReq) {
					name = jsonFieldsNameOfCytologySegmentUpdatePartialUpdateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdatePartialUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateReqPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdatePartialUpdateReqPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentUpdatePartialUpdateReqPointsItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes CytologySegmentUpdatePartialUpdateReqPointsItem from json.
func (s *CytologySegmentUpdatePartialUpdateReqPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdatePartialUpdateReqPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdatePartialUpdateReqPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdatePartialUpdateReqPointsItem) {
					name = jsonFieldsNameOfCytologySegmentUpdatePartialUpdateReqPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdatePartialUpdateReqPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdatePartialUpdateReqPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdateReadOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdateReadOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SegmentGroup.Set {
			e.FieldStart("segment_group")
			s.SegmentGroup.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentUpdateReadOK = [2]string{
	0: "points",
	1: "segment_group",
}

// Decode decodes CytologySegmentUpdateReadOK from json.
func (s *CytologySegmentUpdateReadOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdateReadOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "points":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Points = make([]CytologySegmentUpdateReadOKPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentUpdateReadOKPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "segment_group":
			if err := func() error {
				s.SegmentGroup.Reset()
				if err := s.SegmentGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdateReadOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdateReadOK) {
					name = jsonFieldsNameOfCytologySegmentUpdateReadOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdateReadOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdateReadOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdateReadOKPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdateReadOKPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentUpdateReadOKPointsItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes CytologySegmentUpdateReadOKPointsItem from json.
func (s *CytologySegmentUpdateReadOKPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdateReadOKPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdateReadOKPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdateReadOKPointsItem) {
					name = jsonFieldsNameOfCytologySegmentUpdateReadOKPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdateReadOKPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdateReadOKPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdateUpdateOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdateUpdateOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SegmentGroup.Set {
			e.FieldStart("segment_group")
			s.SegmentGroup.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentUpdateUpdateOK = [2]string{
	0: "points",
	1: "segment_group",
}

// Decode decodes CytologySegmentUpdateUpdateOK from json.
func (s *CytologySegmentUpdateUpdateOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdateUpdateOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "points":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Points = make([]CytologySegmentUpdateUpdateOKPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentUpdateUpdateOKPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "segment_group":
			if err := func() error {
				s.SegmentGroup.Reset()
				if err := s.SegmentGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdateUpdateOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdateUpdateOK) {
					name = jsonFieldsNameOfCytologySegmentUpdateUpdateOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdateUpdateOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdateUpdateOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdateUpdateOKPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdateUpdateOKPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentUpdateUpdateOKPointsItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes CytologySegmentUpdateUpdateOKPointsItem from json.
func (s *CytologySegmentUpdateUpdateOKPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdateUpdateOKPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdateUpdateOKPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdateUpdateOKPointsItem) {
					name = jsonFieldsNameOfCytologySegmentUpdateUpdateOKPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdateUpdateOKPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdateUpdateOKPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdateUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdateUpdateReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SegmentGroup.Set {
			e.FieldStart("segment_group")
			s.SegmentGroup.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentUpdateUpdateReq = [2]string{
	0: "points",
	1: "segment_group",
}

// Decode decodes CytologySegmentUpdateUpdateReq from json.
func (s *CytologySegmentUpdateUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdateUpdateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "points":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Points = make([]CytologySegmentUpdateUpdateReqPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentUpdateUpdateReqPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "segment_group":
			if err := func() error {
				s.SegmentGroup.Reset()
				if err := s.SegmentGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdateUpdateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdateUpdateReq) {
					name = jsonFieldsNameOfCytologySegmentUpdateUpdateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdateUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdateUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentUpdateUpdateReqPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentUpdateUpdateReqPointsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentUpdateUpdateReqPointsItem = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes CytologySegmentUpdateUpdateReqPointsItem from json.
func (s *CytologySegmentUpdateUpdateReqPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentUpdateUpdateReqPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentUpdateUpdateReqPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentUpdateUpdateReqPointsItem) {
					name = jsonFieldsNameOfCytologySegmentUpdateUpdateReqPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentUpdateUpdateReqPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentUpdateUpdateReqPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentsListOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentsListOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCytologySegmentsListOK = [4]string{
	0: "count",
	1: "next",
	2: "previous",
	3: "results",
}

// Decode decodes CytologySegmentsListOK from json.
func (s *CytologySegmentsListOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentsListOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]CytologySegmentsListOKResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentsListOKResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentsListOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentsListOK) {
					name = jsonFieldsNameOfCytologySegmentsListOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentsListOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentsListOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentsListOKResultsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentsListOKResultsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.GroupType.Set {
			e.FieldStart("group_type")
			s.GroupType.Encode(e)
		}
	}
	{
		if s.SegType.Set {
			e.FieldStart("seg_type")
			s.SegType.Encode(e)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.IsAi.Set {
			e.FieldStart("is_ai")
			s.IsAi.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentsListOKResultsItem = [6]string{
	0: "id",
	1: "data",
	2: "group_type",
	3: "seg_type",
	4: "details",
	5: "is_ai",
}

// Decode decodes CytologySegmentsListOKResultsItem from json.
func (s *CytologySegmentsListOKResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentsListOKResultsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]CytologySegmentsListOKResultsItemDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentsListOKResultsItemDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "group_type":
			if err := func() error {
				s.GroupType.Reset()
				if err := s.GroupType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_type\"")
			}
		case "seg_type":
			if err := func() error {
				s.SegType.Reset()
				if err := s.SegType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seg_type\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CytologySegmentsListOKResultsItemDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "is_ai":
			if err := func() error {
				s.IsAi.Reset()
				if err := s.IsAi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ai\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentsListOKResultsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentsListOKResultsItem) {
					name = jsonFieldsNameOfCytologySegmentsListOKResultsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentsListOKResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentsListOKResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentsListOKResultsItemDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentsListOKResultsItemDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("points")
		e.ArrStart()
		for _, elem := range s.Points {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologySegmentsListOKResultsItemDataItem = [3]string{
	0: "id",
	1: "points",
	2: "details",
}

// Decode decodes CytologySegmentsListOKResultsItemDataItem from json.
func (s *CytologySegmentsListOKResultsItemDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentsListOKResultsItemDataItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Points = make([]CytologySegmentsListOKResultsItemDataItemPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CytologySegmentsListOKResultsItemDataItemPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Points = append(s.Points, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentsListOKResultsItemDataItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentsListOKResultsItemDataItem) {
					name = jsonFieldsNameOfCytologySegmentsListOKResultsItemDataItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentsListOKResultsItemDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentsListOKResultsItemDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentsListOKResultsItemDataItemPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentsListOKResultsItemDataItemPointsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("uid")
		e.Int(s.UID)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfCytologySegmentsListOKResultsItemDataItemPointsItem = [4]string{
	0: "id",
	1: "uid",
	2: "x",
	3: "y",
}

// Decode decodes CytologySegmentsListOKResultsItemDataItemPointsItem from json.
func (s *CytologySegmentsListOKResultsItemDataItemPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentsListOKResultsItemDataItemPointsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.UID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentsListOKResultsItemDataItemPointsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologySegmentsListOKResultsItemDataItemPointsItem) {
					name = jsonFieldsNameOfCytologySegmentsListOKResultsItemDataItemPointsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentsListOKResultsItemDataItemPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentsListOKResultsItemDataItemPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologySegmentsListOKResultsItemDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologySegmentsListOKResultsItemDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologySegmentsListOKResultsItemDetails = [0]string{}

// Decode decodes CytologySegmentsListOKResultsItemDetails from json.
func (s *CytologySegmentsListOKResultsItemDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentsListOKResultsItemDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologySegmentsListOKResultsItemDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologySegmentsListOKResultsItemDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentsListOKResultsItemDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologySegmentsListOKResultsItemGroupType as json.
func (s CytologySegmentsListOKResultsItemGroupType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologySegmentsListOKResultsItemGroupType from json.
func (s *CytologySegmentsListOKResultsItemGroupType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentsListOKResultsItemGroupType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologySegmentsListOKResultsItemGroupType(v) {
	case CytologySegmentsListOKResultsItemGroupTypeCE:
		*s = CytologySegmentsListOKResultsItemGroupTypeCE
	case CytologySegmentsListOKResultsItemGroupTypeCL:
		*s = CytologySegmentsListOKResultsItemGroupTypeCL
	case CytologySegmentsListOKResultsItemGroupTypeME:
		*s = CytologySegmentsListOKResultsItemGroupTypeME
	default:
		*s = CytologySegmentsListOKResultsItemGroupType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologySegmentsListOKResultsItemGroupType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentsListOKResultsItemGroupType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologySegmentsListOKResultsItemSegType as json.
func (s CytologySegmentsListOKResultsItemSegType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologySegmentsListOKResultsItemSegType from json.
func (s *CytologySegmentsListOKResultsItemSegType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologySegmentsListOKResultsItemSegType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologySegmentsListOKResultsItemSegType(v) {
	case CytologySegmentsListOKResultsItemSegTypeNIL:
		*s = CytologySegmentsListOKResultsItemSegTypeNIL
	case CytologySegmentsListOKResultsItemSegTypeNIR:
		*s = CytologySegmentsListOKResultsItemSegTypeNIR
	case CytologySegmentsListOKResultsItemSegTypeNIM:
		*s = CytologySegmentsListOKResultsItemSegTypeNIM
	case CytologySegmentsListOKResultsItemSegTypeCNO:
		*s = CytologySegmentsListOKResultsItemSegTypeCNO
	case CytologySegmentsListOKResultsItemSegTypeCGE:
		*s = CytologySegmentsListOKResultsItemSegTypeCGE
	case CytologySegmentsListOKResultsItemSegTypeC2N:
		*s = CytologySegmentsListOKResultsItemSegTypeC2N
	case CytologySegmentsListOKResultsItemSegTypeCPS:
		*s = CytologySegmentsListOKResultsItemSegTypeCPS
	case CytologySegmentsListOKResultsItemSegTypeCFC:
		*s = CytologySegmentsListOKResultsItemSegTypeCFC
	case CytologySegmentsListOKResultsItemSegTypeCLY:
		*s = CytologySegmentsListOKResultsItemSegTypeCLY
	case CytologySegmentsListOKResultsItemSegTypeSOS:
		*s = CytologySegmentsListOKResultsItemSegTypeSOS
	case CytologySegmentsListOKResultsItemSegTypeSDS:
		*s = CytologySegmentsListOKResultsItemSegTypeSDS
	case CytologySegmentsListOKResultsItemSegTypeSMS:
		*s = CytologySegmentsListOKResultsItemSegTypeSMS
	case CytologySegmentsListOKResultsItemSegTypeSTS:
		*s = CytologySegmentsListOKResultsItemSegTypeSTS
	case CytologySegmentsListOKResultsItemSegTypeSPS:
		*s = CytologySegmentsListOKResultsItemSegTypeSPS
	case CytologySegmentsListOKResultsItemSegTypeSNM:
		*s = CytologySegmentsListOKResultsItemSegTypeSNM
	case CytologySegmentsListOKResultsItemSegTypeSTM:
		*s = CytologySegmentsListOKResultsItemSegTypeSTM
	default:
		*s = CytologySegmentsListOKResultsItemSegType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologySegmentsListOKResultsItemSegType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologySegmentsListOKResultsItemSegType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdatePartialUpdateOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdatePartialUpdateOK) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("patient_card")
		s.PatientCard.Encode(e)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.OriginalImage.Set {
			e.FieldStart("original_image")
			s.OriginalImage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyUpdatePartialUpdateOK = [14]string{
	0:  "id",
	1:  "patient_card",
	2:  "details",
	3:  "is_last",
	4:  "diagnos_date",
	5:  "diagnostic_marking",
	6:  "diagnostic_number",
	7:  "material_type",
	8:  "calcitonin",
	9:  "calcitonin_in_flush",
	10: "thyroglobulin",
	11: "prev",
	12: "parent_prev",
	13: "original_image",
}

// Decode decodes CytologyUpdatePartialUpdateOK from json.
func (s *CytologyUpdatePartialUpdateOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateOK to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "patient_card":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CytologyUpdatePartialUpdateOKDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "original_image":
			if err := func() error {
				s.OriginalImage.Reset()
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdatePartialUpdateOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyUpdatePartialUpdateOK) {
					name = jsonFieldsNameOfCytologyUpdatePartialUpdateOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdatePartialUpdateOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdatePartialUpdateOKDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdatePartialUpdateOKDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyUpdatePartialUpdateOKDetails = [0]string{}

// Decode decodes CytologyUpdatePartialUpdateOKDetails from json.
func (s *CytologyUpdatePartialUpdateOKDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateOKDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdatePartialUpdateOKDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdatePartialUpdateOKDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateOKDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdatePartialUpdateOKPatientCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdatePartialUpdateOKPatientCard) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyUpdatePartialUpdateOKPatientCard = [0]string{}

// Decode decodes CytologyUpdatePartialUpdateOKPatientCard from json.
func (s *CytologyUpdatePartialUpdateOKPatientCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateOKPatientCard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdatePartialUpdateOKPatientCard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdatePartialUpdateOKPatientCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateOKPatientCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdatePartialUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdatePartialUpdateReq) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("patient_card")
		s.PatientCard.Encode(e)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.OriginalImage.Set {
			e.FieldStart("original_image")
			s.OriginalImage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyUpdatePartialUpdateReq = [14]string{
	0:  "id",
	1:  "patient_card",
	2:  "details",
	3:  "is_last",
	4:  "diagnos_date",
	5:  "diagnostic_marking",
	6:  "diagnostic_number",
	7:  "material_type",
	8:  "calcitonin",
	9:  "calcitonin_in_flush",
	10: "thyroglobulin",
	11: "prev",
	12: "parent_prev",
	13: "original_image",
}

// Decode decodes CytologyUpdatePartialUpdateReq from json.
func (s *CytologyUpdatePartialUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "patient_card":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CytologyUpdatePartialUpdateReqDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "original_image":
			if err := func() error {
				s.OriginalImage.Reset()
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdatePartialUpdateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyUpdatePartialUpdateReq) {
					name = jsonFieldsNameOfCytologyUpdatePartialUpdateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdatePartialUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdatePartialUpdateReqDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdatePartialUpdateReqDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyUpdatePartialUpdateReqDetails = [0]string{}

// Decode decodes CytologyUpdatePartialUpdateReqDetails from json.
func (s *CytologyUpdatePartialUpdateReqDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateReqDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdatePartialUpdateReqDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdatePartialUpdateReqDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateReqDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdatePartialUpdateReqDiagnosticMarking as json.
func (s CytologyUpdatePartialUpdateReqDiagnosticMarking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyUpdatePartialUpdateReqDiagnosticMarking from json.
func (s *CytologyUpdatePartialUpdateReqDiagnosticMarking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateReqDiagnosticMarking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyUpdatePartialUpdateReqDiagnosticMarking(v) {
	case CytologyUpdatePartialUpdateReqDiagnosticMarking11:
		*s = CytologyUpdatePartialUpdateReqDiagnosticMarking11
	case CytologyUpdatePartialUpdateReqDiagnosticMarking23:
		*s = CytologyUpdatePartialUpdateReqDiagnosticMarking23
	default:
		*s = CytologyUpdatePartialUpdateReqDiagnosticMarking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyUpdatePartialUpdateReqDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateReqDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdatePartialUpdateReqMaterialType as json.
func (s CytologyUpdatePartialUpdateReqMaterialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyUpdatePartialUpdateReqMaterialType from json.
func (s *CytologyUpdatePartialUpdateReqMaterialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateReqMaterialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyUpdatePartialUpdateReqMaterialType(v) {
	case CytologyUpdatePartialUpdateReqMaterialTypeGS:
		*s = CytologyUpdatePartialUpdateReqMaterialTypeGS
	case CytologyUpdatePartialUpdateReqMaterialTypeBP:
		*s = CytologyUpdatePartialUpdateReqMaterialTypeBP
	case CytologyUpdatePartialUpdateReqMaterialTypeTP:
		*s = CytologyUpdatePartialUpdateReqMaterialTypeTP
	case CytologyUpdatePartialUpdateReqMaterialTypePTP:
		*s = CytologyUpdatePartialUpdateReqMaterialTypePTP
	case CytologyUpdatePartialUpdateReqMaterialTypeLNP:
		*s = CytologyUpdatePartialUpdateReqMaterialTypeLNP
	default:
		*s = CytologyUpdatePartialUpdateReqMaterialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyUpdatePartialUpdateReqMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateReqMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdatePartialUpdateReqPatientCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdatePartialUpdateReqPatientCard) encodeFields(e *jx.Encoder) {
	{
		if s.Patient.Set {
			e.FieldStart("patient")
			s.Patient.Encode(e)
		}
	}
	{
		if s.AcceptanceDatetime.Set {
			e.FieldStart("acceptance_datetime")
			s.AcceptanceDatetime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Diagnosis.Set {
			e.FieldStart("diagnosis")
			s.Diagnosis.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyUpdatePartialUpdateReqPatientCard = [3]string{
	0: "patient",
	1: "acceptance_datetime",
	2: "diagnosis",
}

// Decode decodes CytologyUpdatePartialUpdateReqPatientCard from json.
func (s *CytologyUpdatePartialUpdateReqPatientCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdatePartialUpdateReqPatientCard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "patient":
			if err := func() error {
				s.Patient.Reset()
				if err := s.Patient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient\"")
			}
		case "acceptance_datetime":
			if err := func() error {
				s.AcceptanceDatetime.Reset()
				if err := s.AcceptanceDatetime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptance_datetime\"")
			}
		case "diagnosis":
			if err := func() error {
				s.Diagnosis.Reset()
				if err := s.Diagnosis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnosis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdatePartialUpdateReqPatientCard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdatePartialUpdateReqPatientCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdatePartialUpdateReqPatientCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdateUpdateOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdateUpdateOK) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("patient_card")
		s.PatientCard.Encode(e)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.OriginalImage.Set {
			e.FieldStart("original_image")
			s.OriginalImage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyUpdateUpdateOK = [14]string{
	0:  "id",
	1:  "patient_card",
	2:  "details",
	3:  "is_last",
	4:  "diagnos_date",
	5:  "diagnostic_marking",
	6:  "diagnostic_number",
	7:  "material_type",
	8:  "calcitonin",
	9:  "calcitonin_in_flush",
	10: "thyroglobulin",
	11: "prev",
	12: "parent_prev",
	13: "original_image",
}

// Decode decodes CytologyUpdateUpdateOK from json.
func (s *CytologyUpdateUpdateOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateOK to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "patient_card":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		case "details":
			if err := func() error {
				s.Details = nil
				var elem CytologyUpdateUpdateOKDetails
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Details = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "original_image":
			if err := func() error {
				s.OriginalImage.Reset()
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdateUpdateOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyUpdateUpdateOK) {
					name = jsonFieldsNameOfCytologyUpdateUpdateOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdateUpdateOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdateUpdateOKDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdateUpdateOKDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyUpdateUpdateOKDetails = [0]string{}

// Decode decodes CytologyUpdateUpdateOKDetails from json.
func (s *CytologyUpdateUpdateOKDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateOKDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdateUpdateOKDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdateUpdateOKDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateOKDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdateUpdateOKPatientCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdateUpdateOKPatientCard) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCytologyUpdateUpdateOKPatientCard = [0]string{}

// Decode decodes CytologyUpdateUpdateOKPatientCard from json.
func (s *CytologyUpdateUpdateOKPatientCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateOKPatientCard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdateUpdateOKPatientCard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdateUpdateOKPatientCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateOKPatientCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdateUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdateUpdateReq) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("patient_card")
		s.PatientCard.Encode(e)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.OriginalImage.Set {
			e.FieldStart("original_image")
			s.OriginalImage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyUpdateUpdateReq = [14]string{
	0:  "id",
	1:  "patient_card",
	2:  "details",
	3:  "is_last",
	4:  "diagnos_date",
	5:  "diagnostic_marking",
	6:  "diagnostic_number",
	7:  "material_type",
	8:  "calcitonin",
	9:  "calcitonin_in_flush",
	10: "thyroglobulin",
	11: "prev",
	12: "parent_prev",
	13: "original_image",
}

// Decode decodes CytologyUpdateUpdateReq from json.
func (s *CytologyUpdateUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "patient_card":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "original_image":
			if err := func() error {
				s.OriginalImage.Reset()
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdateUpdateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyUpdateUpdateReq) {
					name = jsonFieldsNameOfCytologyUpdateUpdateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdateUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdateUpdateReqDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdateUpdateReqDetails) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsLast.Set {
			e.FieldStart("is_last")
			s.IsLast.Encode(e)
		}
	}
	{
		if s.DiagnosDate.Set {
			e.FieldStart("diagnos_date")
			s.DiagnosDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DiagnosticMarking.Set {
			e.FieldStart("diagnostic_marking")
			s.DiagnosticMarking.Encode(e)
		}
	}
	{
		e.FieldStart("diagnostic_number")
		e.Int(s.DiagnosticNumber)
	}
	{
		if s.MaterialType.Set {
			e.FieldStart("material_type")
			s.MaterialType.Encode(e)
		}
	}
	{
		if s.Calcitonin.Set {
			e.FieldStart("calcitonin")
			s.Calcitonin.Encode(e)
		}
	}
	{
		if s.CalcitoninInFlush.Set {
			e.FieldStart("calcitonin_in_flush")
			s.CalcitoninInFlush.Encode(e)
		}
	}
	{
		if s.Thyroglobulin.Set {
			e.FieldStart("thyroglobulin")
			s.Thyroglobulin.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.ParentPrev.Set {
			e.FieldStart("parent_prev")
			s.ParentPrev.Encode(e)
		}
	}
	{
		if s.PatientCard.Set {
			e.FieldStart("patient_card")
			s.PatientCard.Encode(e)
		}
	}
	{
		if s.OriginalImage.Set {
			e.FieldStart("original_image")
			s.OriginalImage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyUpdateUpdateReqDetails = [13]string{
	0:  "id",
	1:  "is_last",
	2:  "diagnos_date",
	3:  "diagnostic_marking",
	4:  "diagnostic_number",
	5:  "material_type",
	6:  "calcitonin",
	7:  "calcitonin_in_flush",
	8:  "thyroglobulin",
	9:  "prev",
	10: "parent_prev",
	11: "patient_card",
	12: "original_image",
}

// Decode decodes CytologyUpdateUpdateReqDetails from json.
func (s *CytologyUpdateUpdateReqDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateReqDetails to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_last":
			if err := func() error {
				s.IsLast.Reset()
				if err := s.IsLast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_last\"")
			}
		case "diagnos_date":
			if err := func() error {
				s.DiagnosDate.Reset()
				if err := s.DiagnosDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnos_date\"")
			}
		case "diagnostic_marking":
			if err := func() error {
				s.DiagnosticMarking.Reset()
				if err := s.DiagnosticMarking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_marking\"")
			}
		case "diagnostic_number":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DiagnosticNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnostic_number\"")
			}
		case "material_type":
			if err := func() error {
				s.MaterialType.Reset()
				if err := s.MaterialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"material_type\"")
			}
		case "calcitonin":
			if err := func() error {
				s.Calcitonin.Reset()
				if err := s.Calcitonin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin\"")
			}
		case "calcitonin_in_flush":
			if err := func() error {
				s.CalcitoninInFlush.Reset()
				if err := s.CalcitoninInFlush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calcitonin_in_flush\"")
			}
		case "thyroglobulin":
			if err := func() error {
				s.Thyroglobulin.Reset()
				if err := s.Thyroglobulin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thyroglobulin\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "parent_prev":
			if err := func() error {
				s.ParentPrev.Reset()
				if err := s.ParentPrev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_prev\"")
			}
		case "patient_card":
			if err := func() error {
				s.PatientCard.Reset()
				if err := s.PatientCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient_card\"")
			}
		case "original_image":
			if err := func() error {
				s.OriginalImage.Reset()
				if err := s.OriginalImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdateUpdateReqDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCytologyUpdateUpdateReqDetails) {
					name = jsonFieldsNameOfCytologyUpdateUpdateReqDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdateUpdateReqDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateReqDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqDetailsDiagnosticMarking as json.
func (s CytologyUpdateUpdateReqDetailsDiagnosticMarking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyUpdateUpdateReqDetailsDiagnosticMarking from json.
func (s *CytologyUpdateUpdateReqDetailsDiagnosticMarking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateReqDetailsDiagnosticMarking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyUpdateUpdateReqDetailsDiagnosticMarking(v) {
	case CytologyUpdateUpdateReqDetailsDiagnosticMarking11:
		*s = CytologyUpdateUpdateReqDetailsDiagnosticMarking11
	case CytologyUpdateUpdateReqDetailsDiagnosticMarking23:
		*s = CytologyUpdateUpdateReqDetailsDiagnosticMarking23
	default:
		*s = CytologyUpdateUpdateReqDetailsDiagnosticMarking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyUpdateUpdateReqDetailsDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateReqDetailsDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqDetailsMaterialType as json.
func (s CytologyUpdateUpdateReqDetailsMaterialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyUpdateUpdateReqDetailsMaterialType from json.
func (s *CytologyUpdateUpdateReqDetailsMaterialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateReqDetailsMaterialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyUpdateUpdateReqDetailsMaterialType(v) {
	case CytologyUpdateUpdateReqDetailsMaterialTypeGS:
		*s = CytologyUpdateUpdateReqDetailsMaterialTypeGS
	case CytologyUpdateUpdateReqDetailsMaterialTypeBP:
		*s = CytologyUpdateUpdateReqDetailsMaterialTypeBP
	case CytologyUpdateUpdateReqDetailsMaterialTypeTP:
		*s = CytologyUpdateUpdateReqDetailsMaterialTypeTP
	case CytologyUpdateUpdateReqDetailsMaterialTypePTP:
		*s = CytologyUpdateUpdateReqDetailsMaterialTypePTP
	case CytologyUpdateUpdateReqDetailsMaterialTypeLNP:
		*s = CytologyUpdateUpdateReqDetailsMaterialTypeLNP
	default:
		*s = CytologyUpdateUpdateReqDetailsMaterialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyUpdateUpdateReqDetailsMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateReqDetailsMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqDiagnosticMarking as json.
func (s CytologyUpdateUpdateReqDiagnosticMarking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyUpdateUpdateReqDiagnosticMarking from json.
func (s *CytologyUpdateUpdateReqDiagnosticMarking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateReqDiagnosticMarking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyUpdateUpdateReqDiagnosticMarking(v) {
	case CytologyUpdateUpdateReqDiagnosticMarking11:
		*s = CytologyUpdateUpdateReqDiagnosticMarking11
	case CytologyUpdateUpdateReqDiagnosticMarking23:
		*s = CytologyUpdateUpdateReqDiagnosticMarking23
	default:
		*s = CytologyUpdateUpdateReqDiagnosticMarking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyUpdateUpdateReqDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateReqDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqMaterialType as json.
func (s CytologyUpdateUpdateReqMaterialType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CytologyUpdateUpdateReqMaterialType from json.
func (s *CytologyUpdateUpdateReqMaterialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateReqMaterialType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CytologyUpdateUpdateReqMaterialType(v) {
	case CytologyUpdateUpdateReqMaterialTypeGS:
		*s = CytologyUpdateUpdateReqMaterialTypeGS
	case CytologyUpdateUpdateReqMaterialTypeBP:
		*s = CytologyUpdateUpdateReqMaterialTypeBP
	case CytologyUpdateUpdateReqMaterialTypeTP:
		*s = CytologyUpdateUpdateReqMaterialTypeTP
	case CytologyUpdateUpdateReqMaterialTypePTP:
		*s = CytologyUpdateUpdateReqMaterialTypePTP
	case CytologyUpdateUpdateReqMaterialTypeLNP:
		*s = CytologyUpdateUpdateReqMaterialTypeLNP
	default:
		*s = CytologyUpdateUpdateReqMaterialType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CytologyUpdateUpdateReqMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateReqMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CytologyUpdateUpdateReqPatientCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CytologyUpdateUpdateReqPatientCard) encodeFields(e *jx.Encoder) {
	{
		if s.Patient.Set {
			e.FieldStart("patient")
			s.Patient.Encode(e)
		}
	}
	{
		if s.AcceptanceDatetime.Set {
			e.FieldStart("acceptance_datetime")
			s.AcceptanceDatetime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Diagnosis.Set {
			e.FieldStart("diagnosis")
			s.Diagnosis.Encode(e)
		}
	}
}

var jsonFieldsNameOfCytologyUpdateUpdateReqPatientCard = [3]string{
	0: "patient",
	1: "acceptance_datetime",
	2: "diagnosis",
}

// Decode decodes CytologyUpdateUpdateReqPatientCard from json.
func (s *CytologyUpdateUpdateReqPatientCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CytologyUpdateUpdateReqPatientCard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "patient":
			if err := func() error {
				s.Patient.Reset()
				if err := s.Patient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient\"")
			}
		case "acceptance_datetime":
			if err := func() error {
				s.AcceptanceDatetime.Reset()
				if err := s.AcceptanceDatetime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptance_datetime\"")
			}
		case "diagnosis":
			if err := func() error {
				s.Diagnosis.Reset()
				if err := s.Diagnosis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnosis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CytologyUpdateUpdateReqPatientCard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CytologyUpdateUpdateReqPatientCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CytologyUpdateUpdateReqPatientCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Device) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Device) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDevice = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes Device from json.
func (s *Device) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Device to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Device")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDevice) {
					name = jsonFieldsNameOfDevice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Device) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Device) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Doctor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Doctor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("fullname")
		e.Str(s.Fullname)
	}
	{
		e.FieldStart("org")
		e.Str(s.Org)
	}
	{
		e.FieldStart("job")
		e.Str(s.Job)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDoctor = [5]string{
	0: "id",
	1: "fullname",
	2: "org",
	3: "job",
	4: "description",
}

// Decode decodes Doctor from json.
func (s *Doctor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Doctor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fullname":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Fullname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullname\"")
			}
		case "org":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Org = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org\"")
			}
		case "job":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Job = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"job\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Doctor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDoctor) {
					name = jsonFieldsNameOfDoctor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Doctor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Doctor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Echographics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Echographics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		if s.Contors.Set {
			e.FieldStart("contors")
			s.Contors.Encode(e)
		}
	}
	{
		if s.LeftLobeLength.Set {
			e.FieldStart("left_lobe_length")
			s.LeftLobeLength.Encode(e)
		}
	}
	{
		if s.LeftLobeWidth.Set {
			e.FieldStart("left_lobe_width")
			s.LeftLobeWidth.Encode(e)
		}
	}
	{
		if s.LeftLobeThick.Set {
			e.FieldStart("left_lobe_thick")
			s.LeftLobeThick.Encode(e)
		}
	}
	{
		if s.LeftLobeVolum.Set {
			e.FieldStart("left_lobe_volum")
			s.LeftLobeVolum.Encode(e)
		}
	}
	{
		if s.RightLobeLength.Set {
			e.FieldStart("right_lobe_length")
			s.RightLobeLength.Encode(e)
		}
	}
	{
		if s.RightLobeWidth.Set {
			e.FieldStart("right_lobe_width")
			s.RightLobeWidth.Encode(e)
		}
	}
	{
		if s.RightLobeThick.Set {
			e.FieldStart("right_lobe_thick")
			s.RightLobeThick.Encode(e)
		}
	}
	{
		if s.RightLobeVolum.Set {
			e.FieldStart("right_lobe_volum")
			s.RightLobeVolum.Encode(e)
		}
	}
	{
		if s.GlandVolum.Set {
			e.FieldStart("gland_volum")
			s.GlandVolum.Encode(e)
		}
	}
	{
		if s.Isthmus.Set {
			e.FieldStart("isthmus")
			s.Isthmus.Encode(e)
		}
	}
	{
		if s.Struct.Set {
			e.FieldStart("struct")
			s.Struct.Encode(e)
		}
	}
	{
		if s.Echogenicity.Set {
			e.FieldStart("echogenicity")
			s.Echogenicity.Encode(e)
		}
	}
	{
		if s.RegionalLymph.Set {
			e.FieldStart("regional_lymph")
			s.RegionalLymph.Encode(e)
		}
	}
	{
		if s.Vascularization.Set {
			e.FieldStart("vascularization")
			s.Vascularization.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Additional.Set {
			e.FieldStart("additional")
			s.Additional.Encode(e)
		}
	}
	{
		if s.Conclusion.Set {
			e.FieldStart("conclusion")
			s.Conclusion.Encode(e)
		}
	}
}

var jsonFieldsNameOfEchographics = [19]string{
	0:  "id",
	1:  "contors",
	2:  "left_lobe_length",
	3:  "left_lobe_width",
	4:  "left_lobe_thick",
	5:  "left_lobe_volum",
	6:  "right_lobe_length",
	7:  "right_lobe_width",
	8:  "right_lobe_thick",
	9:  "right_lobe_volum",
	10: "gland_volum",
	11: "isthmus",
	12: "struct",
	13: "echogenicity",
	14: "regional_lymph",
	15: "vascularization",
	16: "location",
	17: "additional",
	18: "conclusion",
}

// Decode decodes Echographics from json.
func (s *Echographics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Echographics to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "contors":
			if err := func() error {
				s.Contors.Reset()
				if err := s.Contors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contors\"")
			}
		case "left_lobe_length":
			if err := func() error {
				s.LeftLobeLength.Reset()
				if err := s.LeftLobeLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_lobe_length\"")
			}
		case "left_lobe_width":
			if err := func() error {
				s.LeftLobeWidth.Reset()
				if err := s.LeftLobeWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_lobe_width\"")
			}
		case "left_lobe_thick":
			if err := func() error {
				s.LeftLobeThick.Reset()
				if err := s.LeftLobeThick.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_lobe_thick\"")
			}
		case "left_lobe_volum":
			if err := func() error {
				s.LeftLobeVolum.Reset()
				if err := s.LeftLobeVolum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_lobe_volum\"")
			}
		case "right_lobe_length":
			if err := func() error {
				s.RightLobeLength.Reset()
				if err := s.RightLobeLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"right_lobe_length\"")
			}
		case "right_lobe_width":
			if err := func() error {
				s.RightLobeWidth.Reset()
				if err := s.RightLobeWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"right_lobe_width\"")
			}
		case "right_lobe_thick":
			if err := func() error {
				s.RightLobeThick.Reset()
				if err := s.RightLobeThick.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"right_lobe_thick\"")
			}
		case "right_lobe_volum":
			if err := func() error {
				s.RightLobeVolum.Reset()
				if err := s.RightLobeVolum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"right_lobe_volum\"")
			}
		case "gland_volum":
			if err := func() error {
				s.GlandVolum.Reset()
				if err := s.GlandVolum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gland_volum\"")
			}
		case "isthmus":
			if err := func() error {
				s.Isthmus.Reset()
				if err := s.Isthmus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isthmus\"")
			}
		case "struct":
			if err := func() error {
				s.Struct.Reset()
				if err := s.Struct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"struct\"")
			}
		case "echogenicity":
			if err := func() error {
				s.Echogenicity.Reset()
				if err := s.Echogenicity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"echogenicity\"")
			}
		case "regional_lymph":
			if err := func() error {
				s.RegionalLymph.Reset()
				if err := s.RegionalLymph.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regional_lymph\"")
			}
		case "vascularization":
			if err := func() error {
				s.Vascularization.Reset()
				if err := s.Vascularization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vascularization\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "additional":
			if err := func() error {
				s.Additional.Reset()
				if err := s.Additional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional\"")
			}
		case "conclusion":
			if err := func() error {
				s.Conclusion.Reset()
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Echographics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEchographics) {
					name = jsonFieldsNameOfEchographics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Echographics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Echographics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfError = [1]string{
	0: "message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Image) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Image) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("uzi_id")
		json.EncodeUUID(e, s.UziID)
	}
	{
		e.FieldStart("page")
		e.Int(s.Page)
	}
}

var jsonFieldsNameOfImage = [3]string{
	0: "id",
	1: "uzi_id",
	2: "page",
}

// Decode decodes Image from json.
func (s *Image) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Image to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uzi_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UziID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uzi_id\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Page = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Image")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfImage) {
					name = jsonFieldsNameOfImage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Image) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Image) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginPostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginPostOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
	{
		e.FieldStart("refresh_token")
		e.Str(s.RefreshToken)
	}
}

var jsonFieldsNameOfLoginPostOK = [2]string{
	0: "access_token",
	1: "refresh_token",
}

// Decode decodes LoginPostOK from json.
func (s *LoginPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginPostOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "refresh_token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RefreshToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginPostOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginPostOK) {
					name = jsonFieldsNameOfLoginPostOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfLoginPostReq = [2]string{
	0: "email",
	1: "password",
}

// Decode decodes LoginPostReq from json.
func (s *LoginPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginPostReq) {
					name = jsonFieldsNameOfLoginPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MedCardDoctorIDPatientIDPatchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MedCardDoctorIDPatientIDPatchReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("diagnosis")
		e.Str(s.Diagnosis)
	}
}

var jsonFieldsNameOfMedCardDoctorIDPatientIDPatchReq = [1]string{
	0: "diagnosis",
}

// Decode decodes MedCardDoctorIDPatientIDPatchReq from json.
func (s *MedCardDoctorIDPatientIDPatchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MedCardDoctorIDPatientIDPatchReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "diagnosis":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Diagnosis = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnosis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MedCardDoctorIDPatientIDPatchReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMedCardDoctorIDPatientIDPatchReq) {
					name = jsonFieldsNameOfMedCardDoctorIDPatientIDPatchReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MedCardDoctorIDPatientIDPatchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MedCardDoctorIDPatientIDPatchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MedDoctorIDPatientsGetOKApplicationJSON as json.
func (s MedDoctorIDPatientsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Patient(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes MedDoctorIDPatientsGetOKApplicationJSON from json.
func (s *MedDoctorIDPatientsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MedDoctorIDPatientsGetOKApplicationJSON to nil")
	}
	var unwrapped []Patient
	if err := func() error {
		unwrapped = make([]Patient, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Patient
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MedDoctorIDPatientsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MedDoctorIDPatientsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MedDoctorIDPatientsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MedPatientIDPatchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MedPatientIDPatchReq) encodeFields(e *jx.Encoder) {
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Malignancy.Set {
			e.FieldStart("malignancy")
			s.Malignancy.Encode(e)
		}
	}
}

var jsonFieldsNameOfMedPatientIDPatchReq = [2]string{
	0: "active",
	1: "malignancy",
}

// Decode decodes MedPatientIDPatchReq from json.
func (s *MedPatientIDPatchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MedPatientIDPatchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "malignancy":
			if err := func() error {
				s.Malignancy.Reset()
				if err := s.Malignancy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"malignancy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MedPatientIDPatchReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MedPatientIDPatchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MedPatientIDPatchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MedPatientPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MedPatientPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fullname")
		e.Str(s.Fullname)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("policy")
		e.Str(s.Policy)
	}
	{
		e.FieldStart("active")
		e.Bool(s.Active)
	}
	{
		e.FieldStart("malignancy")
		e.Bool(s.Malignancy)
	}
	{
		e.FieldStart("birth_date")
		json.EncodeDate(e, s.BirthDate)
	}
}

var jsonFieldsNameOfMedPatientPostReq = [6]string{
	0: "fullname",
	1: "email",
	2: "policy",
	3: "active",
	4: "malignancy",
	5: "birth_date",
}

// Decode decodes MedPatientPostReq from json.
func (s *MedPatientPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MedPatientPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fullname":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Fullname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullname\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "policy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Policy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Active = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "malignancy":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Malignancy = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"malignancy\"")
			}
		case "birth_date":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.BirthDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birth_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MedPatientPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMedPatientPostReq) {
					name = jsonFieldsNameOfMedPatientPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MedPatientPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MedPatientPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Node) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Node) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("ai")
		e.Bool(s.Ai)
	}
	{
		e.FieldStart("uzi_id")
		json.EncodeUUID(e, s.UziID)
	}
	{
		if s.Validation.Set {
			e.FieldStart("validation")
			s.Validation.Encode(e)
		}
	}
	{
		e.FieldStart("tirads_23")
		e.Float64(s.Tirads23)
	}
	{
		e.FieldStart("tirads_4")
		e.Float64(s.Tirads4)
	}
	{
		e.FieldStart("tirads_5")
		e.Float64(s.Tirads5)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfNode = [8]string{
	0: "id",
	1: "ai",
	2: "uzi_id",
	3: "validation",
	4: "tirads_23",
	5: "tirads_4",
	6: "tirads_5",
	7: "description",
}

// Decode decodes Node from json.
func (s *Node) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Node to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "ai":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ai = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ai\"")
			}
		case "uzi_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UziID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uzi_id\"")
			}
		case "validation":
			if err := func() error {
				s.Validation.Reset()
				if err := s.Validation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation\"")
			}
		case "tirads_23":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Tirads23 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_23\"")
			}
		case "tirads_4":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Tirads4 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_4\"")
			}
		case "tirads_5":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Tirads5 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_5\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Node")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNode) {
					name = jsonFieldsNameOfNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Node) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Node) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeValidation as json.
func (s NodeValidation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NodeValidation from json.
func (s *NodeValidation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeValidation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NodeValidation(v) {
	case NodeValidationInvalid:
		*s = NodeValidationInvalid
	case NodeValidationValid:
		*s = NodeValidationValid
	default:
		*s = NodeValidation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyCreateCreateCreatedDiagnosticMarking as json.
func (o OptCytologyCreateCreateCreatedDiagnosticMarking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyCreateCreateCreatedDiagnosticMarking from json.
func (o *OptCytologyCreateCreateCreatedDiagnosticMarking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyCreateCreateCreatedDiagnosticMarking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyCreateCreateCreatedDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyCreateCreateCreatedDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyCreateCreateCreatedMaterialType as json.
func (o OptCytologyCreateCreateCreatedMaterialType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyCreateCreateCreatedMaterialType from json.
func (o *OptCytologyCreateCreateCreatedMaterialType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyCreateCreateCreatedMaterialType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyCreateCreateCreatedMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyCreateCreateCreatedMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyHistoryReadOKResultsItemDiagnosticMarking as json.
func (o OptCytologyHistoryReadOKResultsItemDiagnosticMarking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyHistoryReadOKResultsItemDiagnosticMarking from json.
func (o *OptCytologyHistoryReadOKResultsItemDiagnosticMarking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyHistoryReadOKResultsItemDiagnosticMarking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyHistoryReadOKResultsItemDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyHistoryReadOKResultsItemDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyHistoryReadOKResultsItemMaterialType as json.
func (o OptCytologyHistoryReadOKResultsItemMaterialType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyHistoryReadOKResultsItemMaterialType from json.
func (o *OptCytologyHistoryReadOKResultsItemMaterialType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyHistoryReadOKResultsItemMaterialType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyHistoryReadOKResultsItemMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyHistoryReadOKResultsItemMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyReadOKInfoImageGroupDiagnosticMarking as json.
func (o OptCytologyReadOKInfoImageGroupDiagnosticMarking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyReadOKInfoImageGroupDiagnosticMarking from json.
func (o *OptCytologyReadOKInfoImageGroupDiagnosticMarking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyReadOKInfoImageGroupDiagnosticMarking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyReadOKInfoImageGroupDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyReadOKInfoImageGroupDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyReadOKInfoImageGroupMaterialType as json.
func (o OptCytologyReadOKInfoImageGroupMaterialType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyReadOKInfoImageGroupMaterialType from json.
func (o *OptCytologyReadOKInfoImageGroupMaterialType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyReadOKInfoImageGroupMaterialType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyReadOKInfoImageGroupMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyReadOKInfoImageGroupMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologySegmentGroupCreateCreateCreatedData as json.
func (o OptCytologySegmentGroupCreateCreateCreatedData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CytologySegmentGroupCreateCreateCreatedData from json.
func (o *OptCytologySegmentGroupCreateCreateCreatedData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologySegmentGroupCreateCreateCreatedData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologySegmentGroupCreateCreateCreatedData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologySegmentGroupCreateCreateCreatedData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologySegmentsListOKResultsItemGroupType as json.
func (o OptCytologySegmentsListOKResultsItemGroupType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologySegmentsListOKResultsItemGroupType from json.
func (o *OptCytologySegmentsListOKResultsItemGroupType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologySegmentsListOKResultsItemGroupType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologySegmentsListOKResultsItemGroupType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologySegmentsListOKResultsItemGroupType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologySegmentsListOKResultsItemSegType as json.
func (o OptCytologySegmentsListOKResultsItemSegType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologySegmentsListOKResultsItemSegType from json.
func (o *OptCytologySegmentsListOKResultsItemSegType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologySegmentsListOKResultsItemSegType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologySegmentsListOKResultsItemSegType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologySegmentsListOKResultsItemSegType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdatePartialUpdateReqDiagnosticMarking as json.
func (o OptCytologyUpdatePartialUpdateReqDiagnosticMarking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyUpdatePartialUpdateReqDiagnosticMarking from json.
func (o *OptCytologyUpdatePartialUpdateReqDiagnosticMarking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyUpdatePartialUpdateReqDiagnosticMarking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyUpdatePartialUpdateReqDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyUpdatePartialUpdateReqDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdatePartialUpdateReqMaterialType as json.
func (o OptCytologyUpdatePartialUpdateReqMaterialType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyUpdatePartialUpdateReqMaterialType from json.
func (o *OptCytologyUpdatePartialUpdateReqMaterialType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyUpdatePartialUpdateReqMaterialType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyUpdatePartialUpdateReqMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyUpdatePartialUpdateReqMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqDetails as json.
func (o OptCytologyUpdateUpdateReqDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CytologyUpdateUpdateReqDetails from json.
func (o *OptCytologyUpdateUpdateReqDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyUpdateUpdateReqDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyUpdateUpdateReqDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyUpdateUpdateReqDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqDetailsDiagnosticMarking as json.
func (o OptCytologyUpdateUpdateReqDetailsDiagnosticMarking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyUpdateUpdateReqDetailsDiagnosticMarking from json.
func (o *OptCytologyUpdateUpdateReqDetailsDiagnosticMarking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyUpdateUpdateReqDetailsDiagnosticMarking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyUpdateUpdateReqDetailsDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyUpdateUpdateReqDetailsDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqDetailsMaterialType as json.
func (o OptCytologyUpdateUpdateReqDetailsMaterialType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyUpdateUpdateReqDetailsMaterialType from json.
func (o *OptCytologyUpdateUpdateReqDetailsMaterialType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyUpdateUpdateReqDetailsMaterialType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyUpdateUpdateReqDetailsMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyUpdateUpdateReqDetailsMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqDiagnosticMarking as json.
func (o OptCytologyUpdateUpdateReqDiagnosticMarking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyUpdateUpdateReqDiagnosticMarking from json.
func (o *OptCytologyUpdateUpdateReqDiagnosticMarking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyUpdateUpdateReqDiagnosticMarking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyUpdateUpdateReqDiagnosticMarking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyUpdateUpdateReqDiagnosticMarking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CytologyUpdateUpdateReqMaterialType as json.
func (o OptCytologyUpdateUpdateReqMaterialType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CytologyUpdateUpdateReqMaterialType from json.
func (o *OptCytologyUpdateUpdateReqMaterialType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCytologyUpdateUpdateReqMaterialType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCytologyUpdateUpdateReqMaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCytologyUpdateUpdateReqMaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeValidation as json.
func (o OptNilNodeValidation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NodeValidation from json.
func (o *OptNilNodeValidation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNodeValidation to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NodeValidation
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNodeValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNodeValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziNodesIDPatchReqValidation as json.
func (o OptNilUziNodesIDPatchReqValidation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UziNodesIDPatchReqValidation from json.
func (o *OptNilUziNodesIDPatchReqValidation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUziNodesIDPatchReqValidation to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UziNodesIDPatchReqValidation
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUziNodesIDPatchReqValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUziNodesIDPatchReqValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziIDPatchReqProjection as json.
func (o OptUziIDPatchReqProjection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UziIDPatchReqProjection from json.
func (o *OptUziIDPatchReqProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUziIDPatchReqProjection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUziIDPatchReqProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUziIDPatchReqProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes YookassaWebhookRequestObject as json.
func (o OptYookassaWebhookRequestObject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes YookassaWebhookRequestObject from json.
func (o *OptYookassaWebhookRequestObject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptYookassaWebhookRequestObject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptYookassaWebhookRequestObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptYookassaWebhookRequestObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes YookassaWebhookRequestObjectAmount as json.
func (o OptYookassaWebhookRequestObjectAmount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes YookassaWebhookRequestObjectAmount from json.
func (o *OptYookassaWebhookRequestObjectAmount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptYookassaWebhookRequestObjectAmount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptYookassaWebhookRequestObjectAmount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptYookassaWebhookRequestObjectAmount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes YookassaWebhookRequestObjectPaymentMethod as json.
func (o OptYookassaWebhookRequestObjectPaymentMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes YookassaWebhookRequestObjectPaymentMethod from json.
func (o *OptYookassaWebhookRequestObjectPaymentMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptYookassaWebhookRequestObjectPaymentMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptYookassaWebhookRequestObjectPaymentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptYookassaWebhookRequestObjectPaymentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes YookassaWebhookRequestObjectPaymentMethodCard as json.
func (o OptYookassaWebhookRequestObjectPaymentMethodCard) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes YookassaWebhookRequestObjectPaymentMethodCard from json.
func (o *OptYookassaWebhookRequestObjectPaymentMethodCard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptYookassaWebhookRequestObjectPaymentMethodCard to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptYookassaWebhookRequestObjectPaymentMethodCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptYookassaWebhookRequestObjectPaymentMethodCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Patient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Patient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("fullname")
		e.Str(s.Fullname)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("policy")
		e.Str(s.Policy)
	}
	{
		e.FieldStart("active")
		e.Bool(s.Active)
	}
	{
		e.FieldStart("malignancy")
		e.Bool(s.Malignancy)
	}
	{
		e.FieldStart("birth_date")
		json.EncodeDate(e, s.BirthDate)
	}
	{
		if s.LastUziDate.Set {
			e.FieldStart("last_uzi_date")
			s.LastUziDate.Encode(e, json.EncodeDate)
		}
	}
}

var jsonFieldsNameOfPatient = [8]string{
	0: "id",
	1: "fullname",
	2: "email",
	3: "policy",
	4: "active",
	5: "malignancy",
	6: "birth_date",
	7: "last_uzi_date",
}

// Decode decodes Patient from json.
func (s *Patient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Patient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fullname":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Fullname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullname\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "policy":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Policy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Active = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "malignancy":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Malignancy = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"malignancy\"")
			}
		case "birth_date":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.BirthDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birth_date\"")
			}
		case "last_uzi_date":
			if err := func() error {
				s.LastUziDate.Reset()
				if err := s.LastUziDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_uzi_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Patient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPatient) {
					name = jsonFieldsNameOfPatient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Patient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Patient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatientCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatientCard) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.AcceptanceDatetime.Set {
			e.FieldStart("acceptance_datetime")
			s.AcceptanceDatetime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Diagnosis.Set {
			e.FieldStart("diagnosis")
			s.Diagnosis.Encode(e)
		}
	}
	{
		if s.Patient.Set {
			e.FieldStart("patient")
			s.Patient.Encode(e)
		}
	}
	{
		if s.MedWorker.Set {
			e.FieldStart("med_worker")
			s.MedWorker.Encode(e)
		}
	}
}

var jsonFieldsNameOfPatientCard = [5]string{
	0: "id",
	1: "acceptance_datetime",
	2: "diagnosis",
	3: "patient",
	4: "med_worker",
}

// Decode decodes PatientCard from json.
func (s *PatientCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatientCard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "acceptance_datetime":
			if err := func() error {
				s.AcceptanceDatetime.Reset()
				if err := s.AcceptanceDatetime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptance_datetime\"")
			}
		case "diagnosis":
			if err := func() error {
				s.Diagnosis.Reset()
				if err := s.Diagnosis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diagnosis\"")
			}
		case "patient":
			if err := func() error {
				s.Patient.Reset()
				if err := s.Patient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patient\"")
			}
		case "med_worker":
			if err := func() error {
				s.MedWorker.Reset()
				if err := s.MedWorker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"med_worker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatientCard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatientCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatientCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaymentProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaymentProvider) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
}

var jsonFieldsNameOfPaymentProvider = [3]string{
	0: "id",
	1: "name",
	2: "is_active",
}

// Decode decodes PaymentProvider from json.
func (s *PaymentProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaymentProvider to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaymentProvider")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaymentProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaymentProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaymentProvidersGetOKApplicationJSON as json.
func (s PaymentProvidersGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PaymentProvider(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PaymentProvidersGetOKApplicationJSON from json.
func (s *PaymentProvidersGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaymentProvidersGetOKApplicationJSON to nil")
	}
	var unwrapped []PaymentProvider
	if err := func() error {
		unwrapped = make([]PaymentProvider, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PaymentProvider
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PaymentProvidersGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PaymentProvidersGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaymentProvidersGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PurchaseSubscriptionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PurchaseSubscriptionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tariff_plan_id")
		json.EncodeUUID(e, s.TariffPlanID)
	}
	{
		e.FieldStart("payment_provider_id")
		json.EncodeUUID(e, s.PaymentProviderID)
	}
}

var jsonFieldsNameOfPurchaseSubscriptionRequest = [2]string{
	0: "tariff_plan_id",
	1: "payment_provider_id",
}

// Decode decodes PurchaseSubscriptionRequest from json.
func (s *PurchaseSubscriptionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PurchaseSubscriptionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tariff_plan_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TariffPlanID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tariff_plan_id\"")
			}
		case "payment_provider_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PaymentProviderID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_provider_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PurchaseSubscriptionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPurchaseSubscriptionRequest) {
					name = jsonFieldsNameOfPurchaseSubscriptionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PurchaseSubscriptionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PurchaseSubscriptionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PurchaseSubscriptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PurchaseSubscriptionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subscription_id")
		json.EncodeUUID(e, s.SubscriptionID)
	}
	{
		e.FieldStart("confirmation_url")
		e.Str(s.ConfirmationURL)
	}
}

var jsonFieldsNameOfPurchaseSubscriptionResponse = [2]string{
	0: "subscription_id",
	1: "confirmation_url",
}

// Decode decodes PurchaseSubscriptionResponse from json.
func (s *PurchaseSubscriptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PurchaseSubscriptionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscription_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_id\"")
			}
		case "confirmation_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ConfirmationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confirmation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PurchaseSubscriptionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPurchaseSubscriptionResponse) {
					name = jsonFieldsNameOfPurchaseSubscriptionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PurchaseSubscriptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PurchaseSubscriptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RefreshPostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RefreshPostOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
	{
		e.FieldStart("refresh_token")
		e.Str(s.RefreshToken)
	}
}

var jsonFieldsNameOfRefreshPostOK = [2]string{
	0: "access_token",
	1: "refresh_token",
}

// Decode decodes RefreshPostOK from json.
func (s *RefreshPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshPostOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "refresh_token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RefreshToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RefreshPostOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRefreshPostOK) {
					name = jsonFieldsNameOfRefreshPostOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RefreshPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RefreshPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("refresh_token")
		e.Str(s.RefreshToken)
	}
}

var jsonFieldsNameOfRefreshPostReq = [1]string{
	0: "refresh_token",
}

// Decode decodes RefreshPostReq from json.
func (s *RefreshPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "refresh_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RefreshToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RefreshPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRefreshPostReq) {
					name = jsonFieldsNameOfRefreshPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegDoctorPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegDoctorPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("fullname")
		e.Str(s.Fullname)
	}
	{
		e.FieldStart("org")
		e.Str(s.Org)
	}
	{
		e.FieldStart("job")
		e.Str(s.Job)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegDoctorPostReq = [6]string{
	0: "email",
	1: "password",
	2: "fullname",
	3: "org",
	4: "job",
	5: "description",
}

// Decode decodes RegDoctorPostReq from json.
func (s *RegDoctorPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegDoctorPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "fullname":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Fullname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullname\"")
			}
		case "org":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Org = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org\"")
			}
		case "job":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Job = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"job\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegDoctorPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegDoctorPostReq) {
					name = jsonFieldsNameOfRegDoctorPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegDoctorPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegDoctorPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegPatientPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegPatientPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fullname")
		e.Str(s.Fullname)
	}
	{
		e.FieldStart("policy")
		e.Str(s.Policy)
	}
	{
		e.FieldStart("birth_date")
		json.EncodeDate(e, s.BirthDate)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfRegPatientPostReq = [5]string{
	0: "fullname",
	1: "policy",
	2: "birth_date",
	3: "email",
	4: "password",
}

// Decode decodes RegPatientPostReq from json.
func (s *RegPatientPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegPatientPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fullname":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Fullname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullname\"")
			}
		case "policy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Policy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy\"")
			}
		case "birth_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.BirthDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birth_date\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegPatientPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegPatientPostReq) {
					name = jsonFieldsNameOfRegPatientPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegPatientPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegPatientPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Segment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Segment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("image_id")
		json.EncodeUUID(e, s.ImageID)
	}
	{
		e.FieldStart("node_id")
		json.EncodeUUID(e, s.NodeID)
	}
	{
		if s.Contor != nil {
			e.FieldStart("contor")
			s.Contor.Encode(e)
		}
	}
	{
		e.FieldStart("ai")
		e.Bool(s.Ai)
	}
	{
		e.FieldStart("tirads_23")
		e.Float64(s.Tirads23)
	}
	{
		e.FieldStart("tirads_4")
		e.Float64(s.Tirads4)
	}
	{
		e.FieldStart("tirads_5")
		e.Float64(s.Tirads5)
	}
}

var jsonFieldsNameOfSegment = [8]string{
	0: "id",
	1: "image_id",
	2: "node_id",
	3: "contor",
	4: "ai",
	5: "tirads_23",
	6: "tirads_4",
	7: "tirads_5",
}

// Decode decodes Segment from json.
func (s *Segment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Segment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "image_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ImageID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "contor":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Contor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contor\"")
			}
		case "ai":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Ai = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ai\"")
			}
		case "tirads_23":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Tirads23 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_23\"")
			}
		case "tirads_4":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Tirads4 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_4\"")
			}
		case "tirads_5":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Tirads5 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_5\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Segment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegment) {
					name = jsonFieldsNameOfSegment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Segment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Segment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleUuid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleUuid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfSimpleUuid = [1]string{
	0: "id",
}

// Decode decodes SimpleUuid from json.
func (s *SimpleUuid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleUuid to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleUuid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleUuid) {
					name = jsonFieldsNameOfSimpleUuid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleUuid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleUuid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Subscription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Subscription) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("tariff_plan_id")
		json.EncodeUUID(e, s.TariffPlanID)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("start_date")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("end_date")
		json.EncodeDateTime(e, s.EndDate)
	}
}

var jsonFieldsNameOfSubscription = [5]string{
	0: "id",
	1: "tariff_plan_id",
	2: "status",
	3: "start_date",
	4: "end_date",
}

// Decode decodes Subscription from json.
func (s *Subscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Subscription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "tariff_plan_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TariffPlanID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tariff_plan_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "start_date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "end_date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EndDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Subscription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubscription) {
					name = jsonFieldsNameOfSubscription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Subscription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Subscription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionStatus as json.
func (s SubscriptionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubscriptionStatus from json.
func (s *SubscriptionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubscriptionStatus(v) {
	case SubscriptionStatusPendingPayment:
		*s = SubscriptionStatusPendingPayment
	case SubscriptionStatusActive:
		*s = SubscriptionStatusActive
	case SubscriptionStatusCancelled:
		*s = SubscriptionStatusCancelled
	default:
		*s = SubscriptionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubscriptionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsCheckActiveGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsCheckActiveGetOK) encodeFields(e *jx.Encoder) {
	{
		if s.HasActiveSubscription.Set {
			e.FieldStart("has_active_subscription")
			s.HasActiveSubscription.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsCheckActiveGetOK = [1]string{
	0: "has_active_subscription",
}

// Decode decodes SubscriptionsCheckActiveGetOK from json.
func (s *SubscriptionsCheckActiveGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsCheckActiveGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_active_subscription":
			if err := func() error {
				s.HasActiveSubscription.Reset()
				if err := s.HasActiveSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_active_subscription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsCheckActiveGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsCheckActiveGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsCheckActiveGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TariffPlan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TariffPlan) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("price")
		e.Str(s.Price)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
}

var jsonFieldsNameOfTariffPlan = [5]string{
	0: "id",
	1: "name",
	2: "description",
	3: "price",
	4: "duration",
}

// Decode decodes TariffPlan from json.
func (s *TariffPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TariffPlan to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Price = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TariffPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTariffPlan) {
					name = jsonFieldsNameOfTariffPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TariffPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TariffPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TariffPlansGetOKApplicationJSON as json.
func (s TariffPlansGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TariffPlan(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TariffPlansGetOKApplicationJSON from json.
func (s *TariffPlansGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TariffPlansGetOKApplicationJSON to nil")
	}
	var unwrapped []TariffPlan
	if err := func() error {
		unwrapped = make([]TariffPlan, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TariffPlan
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TariffPlansGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TariffPlansGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TariffPlansGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Uzi) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Uzi) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("projection")
		s.Projection.Encode(e)
	}
	{
		e.FieldStart("checked")
		e.Bool(s.Checked)
	}
	{
		e.FieldStart("external_id")
		json.EncodeUUID(e, s.ExternalID)
	}
	{
		e.FieldStart("author_id")
		json.EncodeUUID(e, s.AuthorID)
	}
	{
		e.FieldStart("device_id")
		e.Int(s.DeviceID)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("create_at")
		json.EncodeDateTime(e, s.CreateAt)
	}
}

var jsonFieldsNameOfUzi = [8]string{
	0: "id",
	1: "projection",
	2: "checked",
	3: "external_id",
	4: "author_id",
	5: "device_id",
	6: "status",
	7: "create_at",
}

// Decode decodes Uzi from json.
func (s *Uzi) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Uzi to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "projection":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Projection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projection\"")
			}
		case "checked":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Checked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checked\"")
			}
		case "external_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ExternalID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_id\"")
			}
		case "author_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AuthorID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_id\"")
			}
		case "device_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DeviceID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"device_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "create_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreateAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Uzi")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUzi) {
					name = jsonFieldsNameOfUzi[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Uzi) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Uzi) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziDevicePostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziDevicePostOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
}

var jsonFieldsNameOfUziDevicePostOK = [1]string{
	0: "id",
}

// Decode decodes UziDevicePostOK from json.
func (s *UziDevicePostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziDevicePostOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziDevicePostOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUziDevicePostOK) {
					name = jsonFieldsNameOfUziDevicePostOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziDevicePostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziDevicePostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziDevicePostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziDevicePostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfUziDevicePostReq = [1]string{
	0: "name",
}

// Decode decodes UziDevicePostReq from json.
func (s *UziDevicePostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziDevicePostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziDevicePostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUziDevicePostReq) {
					name = jsonFieldsNameOfUziDevicePostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziDevicePostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziDevicePostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziDevicesGetOKApplicationJSON as json.
func (s UziDevicesGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Device(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UziDevicesGetOKApplicationJSON from json.
func (s *UziDevicesGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziDevicesGetOKApplicationJSON to nil")
	}
	var unwrapped []Device
	if err := func() error {
		unwrapped = make([]Device, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Device
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UziDevicesGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziDevicesGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziDevicesGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziIDImagesGetOKApplicationJSON as json.
func (s UziIDImagesGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Image(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UziIDImagesGetOKApplicationJSON from json.
func (s *UziIDImagesGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDImagesGetOKApplicationJSON to nil")
	}
	var unwrapped []Image
	if err := func() error {
		unwrapped = make([]Image, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Image
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UziIDImagesGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziIDImagesGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDImagesGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziIDNodesGetOKApplicationJSON as json.
func (s UziIDNodesGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Node(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UziIDNodesGetOKApplicationJSON from json.
func (s *UziIDNodesGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDNodesGetOKApplicationJSON to nil")
	}
	var unwrapped []Node
	if err := func() error {
		unwrapped = make([]Node, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Node
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UziIDNodesGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziIDNodesGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDNodesGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziIDNodesSegmentsPostOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziIDNodesSegmentsPostOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("node_id")
		json.EncodeUUID(e, s.NodeID)
	}
	{
		e.FieldStart("segment_ids")
		e.ArrStart()
		for _, elem := range s.SegmentIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUziIDNodesSegmentsPostOK = [2]string{
	0: "node_id",
	1: "segment_ids",
}

// Decode decodes UziIDNodesSegmentsPostOK from json.
func (s *UziIDNodesSegmentsPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDNodesSegmentsPostOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "segment_ids":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.SegmentIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.SegmentIds = append(s.SegmentIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziIDNodesSegmentsPostOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUziIDNodesSegmentsPostOK) {
					name = jsonFieldsNameOfUziIDNodesSegmentsPostOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziIDNodesSegmentsPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDNodesSegmentsPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziIDNodesSegmentsPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziIDNodesSegmentsPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("segments")
		e.ArrStart()
		for _, elem := range s.Segments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUziIDNodesSegmentsPostReq = [2]string{
	0: "node",
	1: "segments",
}

// Decode decodes UziIDNodesSegmentsPostReq from json.
func (s *UziIDNodesSegmentsPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDNodesSegmentsPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "segments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Segments = make([]UziIDNodesSegmentsPostReqSegmentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UziIDNodesSegmentsPostReqSegmentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziIDNodesSegmentsPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUziIDNodesSegmentsPostReq) {
					name = jsonFieldsNameOfUziIDNodesSegmentsPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziIDNodesSegmentsPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDNodesSegmentsPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziIDNodesSegmentsPostReqNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziIDNodesSegmentsPostReqNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tirads_23")
		e.Float64(s.Tirads23)
	}
	{
		e.FieldStart("tirads_4")
		e.Float64(s.Tirads4)
	}
	{
		e.FieldStart("tirads_5")
		e.Float64(s.Tirads5)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfUziIDNodesSegmentsPostReqNode = [4]string{
	0: "tirads_23",
	1: "tirads_4",
	2: "tirads_5",
	3: "description",
}

// Decode decodes UziIDNodesSegmentsPostReqNode from json.
func (s *UziIDNodesSegmentsPostReqNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDNodesSegmentsPostReqNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tirads_23":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Tirads23 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_23\"")
			}
		case "tirads_4":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Tirads4 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_4\"")
			}
		case "tirads_5":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Tirads5 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_5\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziIDNodesSegmentsPostReqNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUziIDNodesSegmentsPostReqNode) {
					name = jsonFieldsNameOfUziIDNodesSegmentsPostReqNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziIDNodesSegmentsPostReqNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDNodesSegmentsPostReqNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziIDNodesSegmentsPostReqSegmentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziIDNodesSegmentsPostReqSegmentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("image_id")
		json.EncodeUUID(e, s.ImageID)
	}
	{
		if s.Contor != nil {
			e.FieldStart("contor")
			s.Contor.Encode(e)
		}
	}
	{
		e.FieldStart("tirads_23")
		e.Float64(s.Tirads23)
	}
	{
		e.FieldStart("tirads_4")
		e.Float64(s.Tirads4)
	}
	{
		e.FieldStart("tirads_5")
		e.Float64(s.Tirads5)
	}
}

var jsonFieldsNameOfUziIDNodesSegmentsPostReqSegmentsItem = [5]string{
	0: "image_id",
	1: "contor",
	2: "tirads_23",
	3: "tirads_4",
	4: "tirads_5",
}

// Decode decodes UziIDNodesSegmentsPostReqSegmentsItem from json.
func (s *UziIDNodesSegmentsPostReqSegmentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDNodesSegmentsPostReqSegmentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "image_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ImageID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_id\"")
			}
		case "contor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Contor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contor\"")
			}
		case "tirads_23":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Tirads23 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_23\"")
			}
		case "tirads_4":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Tirads4 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_4\"")
			}
		case "tirads_5":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Tirads5 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_5\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziIDNodesSegmentsPostReqSegmentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUziIDNodesSegmentsPostReqSegmentsItem) {
					name = jsonFieldsNameOfUziIDNodesSegmentsPostReqSegmentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziIDNodesSegmentsPostReqSegmentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDNodesSegmentsPostReqSegmentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziIDPatchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziIDPatchReq) encodeFields(e *jx.Encoder) {
	{
		if s.Projection.Set {
			e.FieldStart("projection")
			s.Projection.Encode(e)
		}
	}
	{
		if s.Checked.Set {
			e.FieldStart("checked")
			s.Checked.Encode(e)
		}
	}
}

var jsonFieldsNameOfUziIDPatchReq = [2]string{
	0: "projection",
	1: "checked",
}

// Decode decodes UziIDPatchReq from json.
func (s *UziIDPatchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDPatchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projection":
			if err := func() error {
				s.Projection.Reset()
				if err := s.Projection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projection\"")
			}
		case "checked":
			if err := func() error {
				s.Checked.Reset()
				if err := s.Checked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziIDPatchReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziIDPatchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDPatchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziIDPatchReqProjection as json.
func (s UziIDPatchReqProjection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UziIDPatchReqProjection from json.
func (s *UziIDPatchReqProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziIDPatchReqProjection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UziIDPatchReqProjection(v) {
	case UziIDPatchReqProjectionCross:
		*s = UziIDPatchReqProjectionCross
	case UziIDPatchReqProjectionLong:
		*s = UziIDPatchReqProjectionLong
	default:
		*s = UziIDPatchReqProjection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziIDPatchReqProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziIDPatchReqProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziImageIDNodesSegmentsGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziImageIDNodesSegmentsGetOK) encodeFields(e *jx.Encoder) {
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Segments != nil {
			e.FieldStart("segments")
			e.ArrStart()
			for _, elem := range s.Segments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUziImageIDNodesSegmentsGetOK = [2]string{
	0: "nodes",
	1: "segments",
}

// Decode decodes UziImageIDNodesSegmentsGetOK from json.
func (s *UziImageIDNodesSegmentsGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziImageIDNodesSegmentsGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			if err := func() error {
				s.Nodes = make([]Node, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Node
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "segments":
			if err := func() error {
				s.Segments = make([]Segment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Segment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziImageIDNodesSegmentsGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziImageIDNodesSegmentsGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziImageIDNodesSegmentsGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziNodesIDPatchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziNodesIDPatchReq) encodeFields(e *jx.Encoder) {
	{
		if s.Validation.Set {
			e.FieldStart("validation")
			s.Validation.Encode(e)
		}
	}
	{
		if s.Tirads23.Set {
			e.FieldStart("tirads_23")
			s.Tirads23.Encode(e)
		}
	}
	{
		if s.Tirads4.Set {
			e.FieldStart("tirads_4")
			s.Tirads4.Encode(e)
		}
	}
	{
		if s.Tirads5.Set {
			e.FieldStart("tirads_5")
			s.Tirads5.Encode(e)
		}
	}
}

var jsonFieldsNameOfUziNodesIDPatchReq = [4]string{
	0: "validation",
	1: "tirads_23",
	2: "tirads_4",
	3: "tirads_5",
}

// Decode decodes UziNodesIDPatchReq from json.
func (s *UziNodesIDPatchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziNodesIDPatchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "validation":
			if err := func() error {
				s.Validation.Reset()
				if err := s.Validation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation\"")
			}
		case "tirads_23":
			if err := func() error {
				s.Tirads23.Reset()
				if err := s.Tirads23.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_23\"")
			}
		case "tirads_4":
			if err := func() error {
				s.Tirads4.Reset()
				if err := s.Tirads4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_4\"")
			}
		case "tirads_5":
			if err := func() error {
				s.Tirads5.Reset()
				if err := s.Tirads5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_5\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziNodesIDPatchReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziNodesIDPatchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziNodesIDPatchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziNodesIDPatchReqValidation as json.
func (s UziNodesIDPatchReqValidation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UziNodesIDPatchReqValidation from json.
func (s *UziNodesIDPatchReqValidation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziNodesIDPatchReqValidation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UziNodesIDPatchReqValidation(v) {
	case UziNodesIDPatchReqValidationInvalid:
		*s = UziNodesIDPatchReqValidationInvalid
	case UziNodesIDPatchReqValidationValid:
		*s = UziNodesIDPatchReqValidationValid
	default:
		*s = UziNodesIDPatchReqValidation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziNodesIDPatchReqValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziNodesIDPatchReqValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziNodesIDSegmentsGetOKApplicationJSON as json.
func (s UziNodesIDSegmentsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Segment(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UziNodesIDSegmentsGetOKApplicationJSON from json.
func (s *UziNodesIDSegmentsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziNodesIDSegmentsGetOKApplicationJSON to nil")
	}
	var unwrapped []Segment
	if err := func() error {
		unwrapped = make([]Segment, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Segment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UziNodesIDSegmentsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziNodesIDSegmentsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziNodesIDSegmentsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziProjection as json.
func (s UziProjection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UziProjection from json.
func (s *UziProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziProjection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UziProjection(v) {
	case UziProjectionCross:
		*s = UziProjectionCross
	case UziProjectionLong:
		*s = UziProjectionLong
	default:
		*s = UziProjection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziSegmentIDPatchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziSegmentIDPatchReq) encodeFields(e *jx.Encoder) {
	{
		if s.Contor != nil {
			e.FieldStart("contor")
			s.Contor.Encode(e)
		}
	}
	{
		if s.Tirads23.Set {
			e.FieldStart("tirads_23")
			s.Tirads23.Encode(e)
		}
	}
	{
		if s.Tirads4.Set {
			e.FieldStart("tirads_4")
			s.Tirads4.Encode(e)
		}
	}
	{
		if s.Tirads5.Set {
			e.FieldStart("tirads_5")
			s.Tirads5.Encode(e)
		}
	}
}

var jsonFieldsNameOfUziSegmentIDPatchReq = [4]string{
	0: "contor",
	1: "tirads_23",
	2: "tirads_4",
	3: "tirads_5",
}

// Decode decodes UziSegmentIDPatchReq from json.
func (s *UziSegmentIDPatchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziSegmentIDPatchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contor":
			if err := func() error {
				if err := s.Contor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contor\"")
			}
		case "tirads_23":
			if err := func() error {
				s.Tirads23.Reset()
				if err := s.Tirads23.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_23\"")
			}
		case "tirads_4":
			if err := func() error {
				s.Tirads4.Reset()
				if err := s.Tirads4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_4\"")
			}
		case "tirads_5":
			if err := func() error {
				s.Tirads5.Reset()
				if err := s.Tirads5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_5\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziSegmentIDPatchReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziSegmentIDPatchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziSegmentIDPatchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UziSegmentPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UziSegmentPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("image_id")
		json.EncodeUUID(e, s.ImageID)
	}
	{
		e.FieldStart("node_id")
		json.EncodeUUID(e, s.NodeID)
	}
	{
		if s.Contor != nil {
			e.FieldStart("contor")
			s.Contor.Encode(e)
		}
	}
	{
		e.FieldStart("tirads_23")
		e.Float64(s.Tirads23)
	}
	{
		e.FieldStart("tirads_4")
		e.Float64(s.Tirads4)
	}
	{
		e.FieldStart("tirads_5")
		e.Float64(s.Tirads5)
	}
}

var jsonFieldsNameOfUziSegmentPostReq = [6]string{
	0: "image_id",
	1: "node_id",
	2: "contor",
	3: "tirads_23",
	4: "tirads_4",
	5: "tirads_5",
}

// Decode decodes UziSegmentPostReq from json.
func (s *UziSegmentPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziSegmentPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "image_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ImageID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "contor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Contor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contor\"")
			}
		case "tirads_23":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Tirads23 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_23\"")
			}
		case "tirads_4":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Tirads4 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_4\"")
			}
		case "tirads_5":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Tirads5 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tirads_5\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UziSegmentPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUziSegmentPostReq) {
					name = jsonFieldsNameOfUziSegmentPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UziSegmentPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziSegmentPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UziStatus as json.
func (s UziStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UziStatus from json.
func (s *UziStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UziStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UziStatus(v) {
	case UziStatusNew:
		*s = UziStatusNew
	case UziStatusPending:
		*s = UziStatusPending
	case UziStatusCompleted:
		*s = UziStatusCompleted
	default:
		*s = UziStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UziStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UziStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UzisAuthorIDGetOKApplicationJSON as json.
func (s UzisAuthorIDGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Uzi(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UzisAuthorIDGetOKApplicationJSON from json.
func (s *UzisAuthorIDGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UzisAuthorIDGetOKApplicationJSON to nil")
	}
	var unwrapped []Uzi
	if err := func() error {
		unwrapped = make([]Uzi, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Uzi
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UzisAuthorIDGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UzisAuthorIDGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UzisAuthorIDGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UzisExternalIDGetOKApplicationJSON as json.
func (s UzisExternalIDGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Uzi(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UzisExternalIDGetOKApplicationJSON from json.
func (s *UzisExternalIDGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UzisExternalIDGetOKApplicationJSON to nil")
	}
	var unwrapped []Uzi
	if err := func() error {
		unwrapped = make([]Uzi, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Uzi
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UzisExternalIDGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UzisExternalIDGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UzisExternalIDGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *YookassaWebhookRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *YookassaWebhookRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Event.Set {
			e.FieldStart("event")
			s.Event.Encode(e)
		}
	}
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
}

var jsonFieldsNameOfYookassaWebhookRequest = [3]string{
	0: "type",
	1: "event",
	2: "object",
}

// Decode decodes YookassaWebhookRequest from json.
func (s *YookassaWebhookRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode YookassaWebhookRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "event":
			if err := func() error {
				s.Event.Reset()
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode YookassaWebhookRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *YookassaWebhookRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *YookassaWebhookRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *YookassaWebhookRequestObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *YookassaWebhookRequestObject) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Paid.Set {
			e.FieldStart("paid")
			s.Paid.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Metadata != nil {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.PaymentMethod.Set {
			e.FieldStart("payment_method")
			s.PaymentMethod.Encode(e)
		}
	}
	{
		if s.Refundable.Set {
			e.FieldStart("refundable")
			s.Refundable.Encode(e)
		}
	}
	{
		if s.Test.Set {
			e.FieldStart("test")
			s.Test.Encode(e)
		}
	}
}

var jsonFieldsNameOfYookassaWebhookRequestObject = [11]string{
	0:  "id",
	1:  "status",
	2:  "paid",
	3:  "amount",
	4:  "created_at",
	5:  "description",
	6:  "expires_at",
	7:  "metadata",
	8:  "payment_method",
	9:  "refundable",
	10: "test",
}

// Decode decodes YookassaWebhookRequestObject from json.
func (s *YookassaWebhookRequestObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode YookassaWebhookRequestObject to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "paid":
			if err := func() error {
				s.Paid.Reset()
				if err := s.Paid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paid\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata = nil
				var elem YookassaWebhookRequestObjectMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "payment_method":
			if err := func() error {
				s.PaymentMethod.Reset()
				if err := s.PaymentMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_method\"")
			}
		case "refundable":
			if err := func() error {
				s.Refundable.Reset()
				if err := s.Refundable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refundable\"")
			}
		case "test":
			if err := func() error {
				s.Test.Reset()
				if err := s.Test.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode YookassaWebhookRequestObject")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *YookassaWebhookRequestObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *YookassaWebhookRequestObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *YookassaWebhookRequestObjectAmount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *YookassaWebhookRequestObjectAmount) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
}

var jsonFieldsNameOfYookassaWebhookRequestObjectAmount = [2]string{
	0: "value",
	1: "currency",
}

// Decode decodes YookassaWebhookRequestObjectAmount from json.
func (s *YookassaWebhookRequestObjectAmount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode YookassaWebhookRequestObjectAmount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode YookassaWebhookRequestObjectAmount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *YookassaWebhookRequestObjectAmount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *YookassaWebhookRequestObjectAmount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *YookassaWebhookRequestObjectMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *YookassaWebhookRequestObjectMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfYookassaWebhookRequestObjectMetadata = [0]string{}

// Decode decodes YookassaWebhookRequestObjectMetadata from json.
func (s *YookassaWebhookRequestObjectMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode YookassaWebhookRequestObjectMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode YookassaWebhookRequestObjectMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *YookassaWebhookRequestObjectMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *YookassaWebhookRequestObjectMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *YookassaWebhookRequestObjectPaymentMethod) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *YookassaWebhookRequestObjectPaymentMethod) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Saved.Set {
			e.FieldStart("saved")
			s.Saved.Encode(e)
		}
	}
	{
		if s.Card.Set {
			e.FieldStart("card")
			s.Card.Encode(e)
		}
	}
}

var jsonFieldsNameOfYookassaWebhookRequestObjectPaymentMethod = [4]string{
	0: "type",
	1: "id",
	2: "saved",
	3: "card",
}

// Decode decodes YookassaWebhookRequestObjectPaymentMethod from json.
func (s *YookassaWebhookRequestObjectPaymentMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode YookassaWebhookRequestObjectPaymentMethod to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "saved":
			if err := func() error {
				s.Saved.Reset()
				if err := s.Saved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saved\"")
			}
		case "card":
			if err := func() error {
				s.Card.Reset()
				if err := s.Card.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"card\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode YookassaWebhookRequestObjectPaymentMethod")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *YookassaWebhookRequestObjectPaymentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *YookassaWebhookRequestObjectPaymentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *YookassaWebhookRequestObjectPaymentMethodCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *YookassaWebhookRequestObjectPaymentMethodCard) encodeFields(e *jx.Encoder) {
	{
		if s.First6.Set {
			e.FieldStart("first6")
			s.First6.Encode(e)
		}
	}
	{
		if s.Last4.Set {
			e.FieldStart("last4")
			s.Last4.Encode(e)
		}
	}
	{
		if s.ExpiryMonth.Set {
			e.FieldStart("expiry_month")
			s.ExpiryMonth.Encode(e)
		}
	}
	{
		if s.ExpiryYear.Set {
			e.FieldStart("expiry_year")
			s.ExpiryYear.Encode(e)
		}
	}
	{
		if s.CardType.Set {
			e.FieldStart("card_type")
			s.CardType.Encode(e)
		}
	}
	{
		if s.IssuerCountry.Set {
			e.FieldStart("issuer_country")
			s.IssuerCountry.Encode(e)
		}
	}
	{
		if s.IssuerName.Set {
			e.FieldStart("issuer_name")
			s.IssuerName.Encode(e)
		}
	}
}

var jsonFieldsNameOfYookassaWebhookRequestObjectPaymentMethodCard = [7]string{
	0: "first6",
	1: "last4",
	2: "expiry_month",
	3: "expiry_year",
	4: "card_type",
	5: "issuer_country",
	6: "issuer_name",
}

// Decode decodes YookassaWebhookRequestObjectPaymentMethodCard from json.
func (s *YookassaWebhookRequestObjectPaymentMethodCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode YookassaWebhookRequestObjectPaymentMethodCard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "first6":
			if err := func() error {
				s.First6.Reset()
				if err := s.First6.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first6\"")
			}
		case "last4":
			if err := func() error {
				s.Last4.Reset()
				if err := s.Last4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last4\"")
			}
		case "expiry_month":
			if err := func() error {
				s.ExpiryMonth.Reset()
				if err := s.ExpiryMonth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry_month\"")
			}
		case "expiry_year":
			if err := func() error {
				s.ExpiryYear.Reset()
				if err := s.ExpiryYear.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry_year\"")
			}
		case "card_type":
			if err := func() error {
				s.CardType.Reset()
				if err := s.CardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"card_type\"")
			}
		case "issuer_country":
			if err := func() error {
				s.IssuerCountry.Reset()
				if err := s.IssuerCountry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuer_country\"")
			}
		case "issuer_name":
			if err := func() error {
				s.IssuerName.Reset()
				if err := s.IssuerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuer_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode YookassaWebhookRequestObjectPaymentMethodCard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *YookassaWebhookRequestObjectPaymentMethodCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *YookassaWebhookRequestObjectPaymentMethodCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
