// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCard_EncodeDecode(t *testing.T) {
	var typ Card
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Card
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCard_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"diagnosis\":\"опухоль\",\"doctor_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"patient_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Card

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Card
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestContor_EncodeDecode(t *testing.T) {
	var typ Contor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Contor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContorItem_EncodeDecode(t *testing.T) {
	var typ ContorItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContorItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyCopyCreateCreated_EncodeDecode(t *testing.T) {
	var typ CytologyCopyCreateCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyCopyCreateCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyCopyCreateReq_EncodeDecode(t *testing.T) {
	var typ CytologyCopyCreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyCopyCreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyCreateCreateCreated_EncodeDecode(t *testing.T) {
	var typ CytologyCreateCreateCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyCreateCreateCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyCreateCreateCreatedDetails_EncodeDecode(t *testing.T) {
	var typ CytologyCreateCreateCreatedDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyCreateCreateCreatedDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyCreateCreateCreatedDiagnosticMarking_EncodeDecode(t *testing.T) {
	var typ CytologyCreateCreateCreatedDiagnosticMarking
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyCreateCreateCreatedDiagnosticMarking
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyCreateCreateCreatedMaterialType_EncodeDecode(t *testing.T) {
	var typ CytologyCreateCreateCreatedMaterialType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyCreateCreateCreatedMaterialType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyHistoryReadOK_EncodeDecode(t *testing.T) {
	var typ CytologyHistoryReadOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyHistoryReadOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCytologyHistoryReadOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"count\":3,\"next\":null,\"previous\":null,\"results\":[{\"calcitonin\":5,\"calcitonin_in_flush\":2,\"details\":{\"note\":\"Первичное исследование\"},\"diagnos_date\":\"2024-12-21T10:30:00Z\",\"diagnostic_marking\":\"П11\",\"diagnostic_number\":12345,\"id\":1,\"is_last\":true,\"material_type\":\"GS\",\"original_image\":200,\"parent_prev\":null,\"patient_card\":100,\"prev\":null,\"thyroglobulin\":10},{\"calcitonin\":3,\"calcitonin_in_flush\":1,\"details\":{\"note\":\"Повторное исследование\"},\"diagnos_date\":\"2024-12-20T14:20:00Z\",\"diagnostic_marking\":\"Л23\",\"diagnostic_number\":12344,\"id\":2,\"is_last\":false,\"material_type\":\"BP\",\"original_image\":199,\"parent_prev\":null,\"patient_card\":100,\"prev\":1,\"thyroglobulin\":8},{\"calcitonin\":4,\"calcitonin_in_flush\":2,\"details\":null,\"diagnos_date\":\"2024-12-19T09:15:00Z\",\"diagnostic_marking\":\"П11\",\"diagnostic_number\":12343,\"id\":3,\"is_last\":false,\"material_type\":\"TP\",\"original_image\":198,\"parent_prev\":null,\"patient_card\":100,\"prev\":2,\"thyroglobulin\":9}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CytologyHistoryReadOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CytologyHistoryReadOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCytologyHistoryReadOKResultsItem_EncodeDecode(t *testing.T) {
	var typ CytologyHistoryReadOKResultsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyHistoryReadOKResultsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyHistoryReadOKResultsItemDetails_EncodeDecode(t *testing.T) {
	var typ CytologyHistoryReadOKResultsItemDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyHistoryReadOKResultsItemDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyHistoryReadOKResultsItemDiagnosticMarking_EncodeDecode(t *testing.T) {
	var typ CytologyHistoryReadOKResultsItemDiagnosticMarking
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyHistoryReadOKResultsItemDiagnosticMarking
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyHistoryReadOKResultsItemMaterialType_EncodeDecode(t *testing.T) {
	var typ CytologyHistoryReadOKResultsItemMaterialType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyHistoryReadOKResultsItemMaterialType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyReadOK_EncodeDecode(t *testing.T) {
	var typ CytologyReadOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyReadOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyReadOKInfo_EncodeDecode(t *testing.T) {
	var typ CytologyReadOKInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyReadOKInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyReadOKInfoImageGroup_EncodeDecode(t *testing.T) {
	var typ CytologyReadOKInfoImageGroup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyReadOKInfoImageGroup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyReadOKInfoImageGroupDetails_EncodeDecode(t *testing.T) {
	var typ CytologyReadOKInfoImageGroupDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyReadOKInfoImageGroupDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyReadOKInfoImageGroupDiagnosticMarking_EncodeDecode(t *testing.T) {
	var typ CytologyReadOKInfoImageGroupDiagnosticMarking
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyReadOKInfoImageGroupDiagnosticMarking
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyReadOKInfoImageGroupMaterialType_EncodeDecode(t *testing.T) {
	var typ CytologyReadOKInfoImageGroupMaterialType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyReadOKInfoImageGroupMaterialType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyReadOKOriginalImage_EncodeDecode(t *testing.T) {
	var typ CytologyReadOKOriginalImage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyReadOKOriginalImage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentGroupCreateCreateCreated_EncodeDecode(t *testing.T) {
	var typ CytologySegmentGroupCreateCreateCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentGroupCreateCreateCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentGroupCreateCreateCreatedData_EncodeDecode(t *testing.T) {
	var typ CytologySegmentGroupCreateCreateCreatedData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentGroupCreateCreateCreatedData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentGroupCreateCreateCreatedDataPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentGroupCreateCreateCreatedDataPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentGroupCreateCreateCreatedDataPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentGroupCreateCreateReq_EncodeDecode(t *testing.T) {
	var typ CytologySegmentGroupCreateCreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentGroupCreateCreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentGroupCreateCreateReqData_EncodeDecode(t *testing.T) {
	var typ CytologySegmentGroupCreateCreateReqData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentGroupCreateCreateReqData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentGroupCreateCreateReqDataPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentGroupCreateCreateReqDataPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentGroupCreateCreateReqDataPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentGroupCreateCreateReqSegType_EncodeDecode(t *testing.T) {
	var typ CytologySegmentGroupCreateCreateReqSegType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentGroupCreateCreateReqSegType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdatePartialUpdateOK_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdatePartialUpdateOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdatePartialUpdateOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdatePartialUpdateOKPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdatePartialUpdateOKPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdatePartialUpdateOKPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdatePartialUpdateReq_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdatePartialUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdatePartialUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdatePartialUpdateReqPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdatePartialUpdateReqPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdatePartialUpdateReqPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdateReadOK_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdateReadOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdateReadOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdateReadOKPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdateReadOKPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdateReadOKPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdateUpdateOK_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdateUpdateOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdateUpdateOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdateUpdateOKPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdateUpdateOKPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdateUpdateOKPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdateUpdateReq_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdateUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdateUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentUpdateUpdateReqPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentUpdateUpdateReqPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentUpdateUpdateReqPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentsListOK_EncodeDecode(t *testing.T) {
	var typ CytologySegmentsListOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentsListOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentsListOKResultsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentsListOKResultsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentsListOKResultsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentsListOKResultsItemDataItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentsListOKResultsItemDataItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentsListOKResultsItemDataItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentsListOKResultsItemDataItemPointsItem_EncodeDecode(t *testing.T) {
	var typ CytologySegmentsListOKResultsItemDataItemPointsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentsListOKResultsItemDataItemPointsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentsListOKResultsItemDetails_EncodeDecode(t *testing.T) {
	var typ CytologySegmentsListOKResultsItemDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentsListOKResultsItemDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentsListOKResultsItemGroupType_EncodeDecode(t *testing.T) {
	var typ CytologySegmentsListOKResultsItemGroupType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentsListOKResultsItemGroupType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologySegmentsListOKResultsItemSegType_EncodeDecode(t *testing.T) {
	var typ CytologySegmentsListOKResultsItemSegType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologySegmentsListOKResultsItemSegType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateOK_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateOKDetails_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateOKDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateOKDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateOKPatientCard_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateOKPatientCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateOKPatientCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateReq_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateReqDetails_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateReqDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateReqDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateReqDiagnosticMarking_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateReqDiagnosticMarking
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateReqDiagnosticMarking
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateReqMaterialType_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateReqMaterialType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateReqMaterialType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdatePartialUpdateReqPatientCard_EncodeDecode(t *testing.T) {
	var typ CytologyUpdatePartialUpdateReqPatientCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdatePartialUpdateReqPatientCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateOK_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateOKDetails_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateOKDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateOKDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateOKPatientCard_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateOKPatientCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateOKPatientCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateReq_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateReqDetails_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateReqDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateReqDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateReqDetailsDiagnosticMarking_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateReqDetailsDiagnosticMarking
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateReqDetailsDiagnosticMarking
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateReqDetailsMaterialType_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateReqDetailsMaterialType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateReqDetailsMaterialType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateReqDiagnosticMarking_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateReqDiagnosticMarking
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateReqDiagnosticMarking
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateReqMaterialType_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateReqMaterialType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateReqMaterialType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCytologyUpdateUpdateReqPatientCard_EncodeDecode(t *testing.T) {
	var typ CytologyUpdateUpdateReqPatientCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CytologyUpdateUpdateReqPatientCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDevice_EncodeDecode(t *testing.T) {
	var typ Device
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Device
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDevice_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1,\"name\":\"ульпанатор 3000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Device

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Device
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDoctor_EncodeDecode(t *testing.T) {
	var typ Doctor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Doctor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDoctor_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"работает в медицинском центре с 2010 года\",\"fullname\":\"Иван Иванов\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"job\":\"Хирург\",\"org\":\"Медицинский центр\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Doctor

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Doctor
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEchographics_EncodeDecode(t *testing.T) {
	var typ Echographics
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Echographics
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEchographics_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"additional\":\"видны последстввия нездорового образа жизни\",\"conclusion\":\"требуется лечение\",\"contors\":\"контуры\",\"echogenicity\":\"эхогенность\",\"gland_volum\":100,\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"isthmus\":100,\"left_lobe_length\":100,\"left_lobe_thick\":100,\"left_lobe_volum\":100,\"left_lobe_width\":100,\"location\":\"в правой части\",\"regional_lymph\":\"в правой части\",\"right_lobe_length\":100,\"right_lobe_thick\":100,\"right_lobe_volum\":100,\"right_lobe_width\":100,\"struct\":\"квадрат\",\"vascularization\":\"выраженная\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Echographics

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Echographics
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestImage_EncodeDecode(t *testing.T) {
	var typ Image
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Image
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestImage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"page\":1,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Image

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Image
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLoginPostOK_EncodeDecode(t *testing.T) {
	var typ LoginPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoginPostReq_EncodeDecode(t *testing.T) {
	var typ LoginPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestLoginPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"email\":\"test@test.com\",\"password\":\"qwerty123\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ LoginPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 LoginPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMedCardDoctorIDPatientIDPatchReq_EncodeDecode(t *testing.T) {
	var typ MedCardDoctorIDPatientIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedCardDoctorIDPatientIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedDoctorIDPatientsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ MedDoctorIDPatientsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedDoctorIDPatientsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedPatientIDPatchReq_EncodeDecode(t *testing.T) {
	var typ MedPatientIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedPatientIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedPatientPostReq_EncodeDecode(t *testing.T) {
	var typ MedPatientPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedPatientPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNode_EncodeDecode(t *testing.T) {
	var typ Node
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Node
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNode_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ai\":true,\"description\":\"узел явно неправильный\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"validation\":\"invalid\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Node

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Node
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNodeValidation_EncodeDecode(t *testing.T) {
	var typ NodeValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatient_EncodeDecode(t *testing.T) {
	var typ Patient
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Patient
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPatient_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"birth_date\":\"2021-01-01\",\"email\":\"ivan@example.com\",\"fullname\":\"Иван Иванов\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"last_uzi_date\":\"2024-01-01\",\"malignancy\":false,\"policy\":\"1234567890\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Patient

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Patient
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPatientCard_EncodeDecode(t *testing.T) {
	var typ PatientCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatientCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaymentProvider_EncodeDecode(t *testing.T) {
	var typ PaymentProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPaymentProvider_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"is_active\":true,\"name\":\"Yookassa\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PaymentProvider

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PaymentProvider
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPaymentProvidersGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PaymentProvidersGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentProvidersGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPurchaseSubscriptionRequest_EncodeDecode(t *testing.T) {
	var typ PurchaseSubscriptionRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PurchaseSubscriptionRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPurchaseSubscriptionRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"payment_provider_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tariff_plan_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PurchaseSubscriptionRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PurchaseSubscriptionRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPurchaseSubscriptionResponse_EncodeDecode(t *testing.T) {
	var typ PurchaseSubscriptionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PurchaseSubscriptionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPurchaseSubscriptionResponse_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"confirmation_url\":\"https://example.com/confirm\",\"subscription_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PurchaseSubscriptionResponse

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PurchaseSubscriptionResponse
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRefreshPostOK_EncodeDecode(t *testing.T) {
	var typ RefreshPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RefreshPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRefreshPostReq_EncodeDecode(t *testing.T) {
	var typ RefreshPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RefreshPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRefreshPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"refresh_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RefreshPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RefreshPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRegDoctorPostReq_EncodeDecode(t *testing.T) {
	var typ RegDoctorPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegDoctorPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRegDoctorPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"работает в медицинском центре с 2010 года\",\"email\":\"test@test.com\",\"fullname\":\"Иван Иванов\",\"job\":\"Хирург\",\"org\":\"Медицинский центр\",\"password\":\"qwerty123\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RegDoctorPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RegDoctorPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRegPatientPostReq_EncodeDecode(t *testing.T) {
	var typ RegPatientPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegPatientPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRegPatientPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"birth_date\":\"2021-01-01\",\"email\":\"test@test.com\",\"fullname\":\"Иван Иванов\",\"password\":\"qwerty123\",\"policy\":\"1234567890\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RegPatientPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RegPatientPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSegment_EncodeDecode(t *testing.T) {
	var typ Segment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Segment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSegment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ai\":false,\"contor\":[{\"true\":100,\"x\":100},{\"true\":200,\"x\":200}],\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"image_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"node_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.45,\"tirads_4\":0.78,\"tirads_5\":0.12}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Segment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Segment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSimpleUuid_EncodeDecode(t *testing.T) {
	var typ SimpleUuid
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleUuid
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSimpleUuid_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SimpleUuid

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SimpleUuid
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSubscription_EncodeDecode(t *testing.T) {
	var typ Subscription
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Subscription
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSubscription_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"end_date\":\"2023-12-31T23:59:59Z\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"start_date\":\"2023-01-01T00:00:00Z\",\"status\":\"active\",\"tariff_plan_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Subscription

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Subscription
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSubscriptionStatus_EncodeDecode(t *testing.T) {
	var typ SubscriptionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionsCheckActiveGetOK_EncodeDecode(t *testing.T) {
	var typ SubscriptionsCheckActiveGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionsCheckActiveGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTariffPlan_EncodeDecode(t *testing.T) {
	var typ TariffPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TariffPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTariffPlan_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"This is a basic tariff plan.\",\"duration\":2592000000000000,\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"name\":\"Basic Plan\",\"price\":\"9.99\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TariffPlan

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TariffPlan
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTariffPlansGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ TariffPlansGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TariffPlansGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzi_EncodeDecode(t *testing.T) {
	var typ Uzi
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Uzi
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUzi_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"checked\":false,\"create_at\":\"2021-01-01T00:00:00Z\",\"device_id\":1,\"external_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"projection\":\"cross\",\"status\":\"pending\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Uzi

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Uzi
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostOK_EncodeDecode(t *testing.T) {
	var typ UziDevicePostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostReq_EncodeDecode(t *testing.T) {
	var typ UziDevicePostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Siemens\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziDevicesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDImagesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDImagesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDImagesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDNodesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostOK_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReq_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReqNode_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReqNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReqNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReqSegmentsItem_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReqSegmentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReqSegmentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"checked\":true,\"projection\":\"cross\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziIDPatchReqProjection_EncodeDecode(t *testing.T) {
	var typ UziIDPatchReqProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDPatchReqProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziImageIDNodesSegmentsGetOK_EncodeDecode(t *testing.T) {
	var typ UziImageIDNodesSegmentsGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziImageIDNodesSegmentsGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziNodesIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziNodesIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89,\"validation\":\"invalid\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziNodesIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziNodesIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziNodesIDPatchReqValidation_EncodeDecode(t *testing.T) {
	var typ UziNodesIDPatchReqValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDPatchReqValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesIDSegmentsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziNodesIDSegmentsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDSegmentsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziProjection_EncodeDecode(t *testing.T) {
	var typ UziProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziSegmentIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziSegmentIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contor\":[{\"true\":100,\"x\":100},{\"true\":200,\"x\":200}],\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziSegmentIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziSegmentIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziSegmentPostReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziStatus_EncodeDecode(t *testing.T) {
	var typ UziStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzisAuthorIDGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UzisAuthorIDGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UzisAuthorIDGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzisExternalIDGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UzisExternalIDGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UzisExternalIDGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequest_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestYookassaWebhookRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"event\":\"payment.waiting_for_capture\",\"object\":{\"amount\":{\"currency\":\"RUB\",\"value\":\"2.00\"},\"created_at\":\"2018-07-10T14:27:54.691Z\",\"description\":\"Заказ №72\",\"expires_at\":\"2018-07-17T14:28:32.484Z\",\"id\":\"22d6d597-000f-5000-9000-145f6df21d6f\",\"metadata\":{},\"paid\":true,\"payment_method\":{\"card\":{\"card_type\":\"MasterCard\",\"expiry_month\":\"07\",\"expiry_year\":\"2021\",\"first6\":\"555555\",\"issuer_country\":\"RU\",\"issuer_name\":\"Sberbank\",\"last4\":\"4444\"},\"id\":\"22d6d597-000f-5000-9000-145f6df21d6f\",\"saved\":false,\"type\":\"bank_card\"},\"refundable\":false,\"status\":\"waiting_for_capture\",\"test\":false},\"type\":\"notification\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ YookassaWebhookRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 YookassaWebhookRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestYookassaWebhookRequestObject_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectAmount_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectAmount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectAmount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectMetadata_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectPaymentMethod_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectPaymentMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectPaymentMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectPaymentMethodCard_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectPaymentMethodCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectPaymentMethodCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
